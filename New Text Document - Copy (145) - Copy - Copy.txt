
About
Products
For Teams
Search…
Join Stack Overflow to find the best answer to your technical question, help others answer theirs.

Home
PUBLIC
Questions
Tags
Users
Companies
COLLECTIVES
Explore Collectives
TEAMS
Stack Overflow for Teams – Start collaborating and sharing organizational knowledge. 
Generating Random Files in Windows
Asked 14 years, 3 months ago
Modified 5 months ago
Viewed 85k times
42

Does anyone have a way to generate files of random data in Windows? I would like to generate 50,000 small (2K) files as an example.

windows
Share
Improve this question
Follow
asked Feb 10, 2009 at 18:51
Jeff
2
Could you share with us whether you want text files or binary files? Could you also comment as to what programming languages you have access to (if any)? Do you have MS Office installed? Also, not very relevant, but what version of windows are you using? – 
user62572
 Feb 10, 2009 at 20:05
Add a comment
16 Answers
Sorted by:

Highest score (default)
34

You can run fsutil in a batch loop to create files of any size.

fsutil file createnew filename.extension 2000
Share
Improve this answer
Follow
answered Feb 10, 2009 at 19:01
Bogdan's user avatar
Bogdan
3,03511 gold badge2222 silver badges2020 bronze badges
I just found that utility. Didn't know it existed before. thebackroomtech.com/2009/01/16/… – 
beach
 Feb 10, 2009 at 19:04
41
However, it doesn't create random data. Just blank files. – 
beach
 Feb 10, 2009 at 19:07
And it seems to require admin permissions. Going with the powershell. – 
Mathias Mamsch
 Oct 25, 2017 at 7:21
Add a comment
21

One-liner in Powershell:

$out = new-object byte[] 1048576; (new-object Random).NextBytes($out); [IO.File]::WriteAllBytes('d:\file.bin', $out)
This is lightning fast, compared to @user188737 solution.

Share
Improve this answer
Follow
answered Sep 26, 2017 at 7:07
gwiazdorrr's user avatar
gwiazdorrr
6,16122 gold badges2727 silver badges3636 bronze badges
1
Every single file that this one liner creates is identical. Is there any way to make the content of each file different – 
Dhiwakar Ravikumar
 Apr 15, 2018 at 4:47
3
Are you sure this is the case? I tried it on my system, ran it 3 times, got 3 distinct files. The constructor for the Random type is by default based on the system time, so perhaps if you run this multiple times in very quick succession, you might get identical files. You could avoid this by creating a single Random object and then reusing it for each consecutive file: $rnd = New-Object Random; once at the top, and then $rnd.NextBytes instead of (New-Object Random).NextBytes when generating the file. – 
Jonathan Gilbert
 May 29, 2018 at 16:19
Add a comment
18

You can use PowerShell to generate cheap random data for your files:

[Byte[]] $out = @()
0..2047 | % {$out += Get-Random -Minimum 0 -Maximum 255}
[System.IO.File]::WriteAllBytes("myrandomfiletest", $out)
This uses an algorithm with a seed taken from the system clock, so don't use this for ANY serious cryptographic applications.

In addition, be wary of the performance degradation of Get-Random when increasing the size of the output file. More on this aspect here:

PowerShell random file generator too slow
Improve Powershell Performance to Generate a Random File
Share
Improve this answer
Follow
edited May 23, 2017 at 12:32
Community's user avatar
CommunityBot
111 silver badge
answered Sep 27, 2013 at 18:23
Gerrit's user avatar
Gerrit
85166 silver badges1111 bronze badges
Add a comment
16

I have been using Random Data File Creator and liking it, it creates binary files (i.e. not text files) filled with pseudo-random bits, it can quickly create very large files. To use it to create multiple small files you would need to script it, which would be very easy given it is command line.

Share
Improve this answer
Follow
edited Dec 25, 2015 at 11:57
mguassa's user avatar
mguassa
3,97122 gold badges1414 silver badges1919 bronze badges
answered Feb 5, 2010 at 19:20
David Waters's user avatar
David Waters
11.9k77 gold badges4141 silver badges7676 bronze badges
There are quite a few programs and cloud tools of this nature: raywoodcockslatest.wordpress.com/2021/08/21/dummy-files – 
Ray Woodcock
 May 17, 2022 at 14:08
Add a comment
8

Since you don't specify a language, I'll simply pick one at random. Here is a powershell script to do it:

$rootDir = 'C:\Temp\TestRandomFiles\'
$baseFile = $rootDir + "base.txt"
$desiredFileSize = 2*1KB
$fileCount = 50000
"start" | Out-File -Filepath $baseFile
While ($(Get-ChildItem -path $baseFile).Length -lt $desiredFileSize)
{
    $(Get-ChildItem -path $baseFile).Length | Out-File $baseFile -APPEND
}
for($i=1;$i -lt $fileCount;$i++)
{
    Copy-Item $baseFile "File$i.txt"
}
You'll have to change the variables to the parameters that you want of course.

Share
Improve this answer
Follow
answered Feb 10, 2009 at 19:47
EBGreen's user avatar
EBGreen
36.5k1212 gold badges6464 silver badges8484 bronze badges
1
oops...missed the random data requirement. Is that important? If so I can tweak it. – 
EBGreen
 Feb 10, 2009 at 19:48
1
If you are a PS whiz, I don't suppose you can do random data as I am keen to learn how this done! – 
Wil
 Jan 27, 2012 at 10:22 
I'm definitely not a whiz, but there are several ways. Basically you identify the data set that you want to randomize (say 0-9 and a-Z) then you randomly pick from that set to build the data for the file, then write it out to the file. If I have a chance later today, I'll alter the above code to use random data. – 
EBGreen
 Jan 27, 2012 at 15:12
@EBGreen thank You much! Best regards – 
Gennady G
 Nov 29, 2021 at 14:01
Add a comment
4

Instead of using Get-Random to generate the text as per user188737 & mguassa suggestions, I improved the speed by using GUIDs.

Function New-RandomFile {
    Param(
        $Path = '.', 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 
    (1..($FileSize/128)).foreach({-join ([guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-").SubString(1, 126) }) | set-content "$Path\$FileName"
}
This took 491 milliseconds to generate a 1mb file. Running:

New-RandomFile -FileSize 1mb
UPDATE:

I've updated my function to use a ScriptBlock, so you can replace the 'NewGuid()' method with anything you want.

In this scenario, I make 1kb chunks, since I know I'm never creating smaller files. This improved the speed of my function drastically!

Set-Content forces a NewLine at the end, which is why you need to remove 2 Characters each time you write to file. I've replaced it with [io.file]::WriteAllText() instead.

Function New-RandomFile_1kChunks {
    Param(
        $Path = (Resolve-Path '.').Path, 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 

    $Chunk = { [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-" }

    $Chunks = [math]::Ceiling($FileSize/1kb)

    [io.file]::WriteAllText("$Path\$FileName","$(-Join (1..($Chunks)).foreach({ $Chunk.Invoke() }))")

    Write-Warning "New-RandomFile: $Path\$FileName"

}
If you dont care that all chunks are random, you can simply Invoke() the generation of the 1kb chunk once.. this improves the speed drastically, but won't make the entire file random.

Function New-RandomFile_Fast {
    Param(
        $Path = (Resolve-Path '.').Path, 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 

    $Chunk = { [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-" }
    $Chunks = [math]::Ceiling($FileSize/1kb)
    $ChunkString = $Chunk.Invoke()

    [io.file]::WriteAllText("$Path\$FileName","$(-Join (1..($Chunks)).foreach({ $ChunkString }))")

    Write-Warning "New-RandomFile: $Path\$FileName"

}
Measure-Command all these changes to generate a 10mb file:

Executing New-RandomFile: 35.7688241 seconds.

Executing New-RandomFile_1kChunks: 25.1463777 seconds.

Executing New-RandomFile_Fast: 1.1626236 seconds.

Share
Improve this answer
Follow
edited Apr 3, 2017 at 23:04
answered Apr 1, 2017 at 2:39
Marc Kellerman's user avatar
Marc Kellerman
45622 silver badges1010 bronze badges
Add a comment
2

You'll have to create files in the normal way, and then populate them with randomized data, probably from a rand() function of some sort.

It really depends on your programming language. Windows itself certainly won't provide this capability.

There are a number of programming languages that could do this easily, however, including basic windows batch/CMD scripts. What language are you interested in using?

Share
Improve this answer
Follow
answered Feb 10, 2009 at 18:54
levand's user avatar
levand
8,39033 gold badges4040 silver badges5454 bronze badges
Add a comment
2

None of the answers here were cutting it for me, so here's a script which takes advantage of the Cryptography library to generate lots of random files.

This will generate files very quickly until your system's entropy is exhausted (on my PC this was about 4,000 files). After this it (and any other applications on your system that need cryptographic random numbers) will run very slowly. (In Linux terms, consider this script to use /dev/random instead of /dev/urandom)

$directory = (Get-Location).Path;
0..10000 | ForEach-Object {
    $size = 1023 * (Get-Random -Minimum 10 -Maximum 1536);
    $contents = [Byte[]]::new($size);

    $rng = [System.Security.Cryptography.RNGCryptoServiceProvider]::new();
    $rng.GetBytes($contents);

    $filename = "$directory\random$($_.ToString().PadLeft(5, '0')).txt"
    Write-Host $filename
    [System.IO.File]::WriteAllBytes($filename, $contents)
}
If you'd rather not deplete your system's entropy, replace the two $rng lines with these:

    $rng = [System.Random]::new();
    $rng.NextBytes($contents);
This will run much slower, but for large quantities of files (or larger files) it should be more reliable.

Share
Improve this answer
Follow
answered Apr 15, 2020 at 0:57
Joshua Walsh's user avatar
Joshua Walsh
1,88555 gold badges2525 silver badges5050 bronze badges
Add a comment
1

Yes, fsutil is great, but doesn't generate random data, just ASCII nulls.

I don't remember where I found this but searching on google these days I can still find it at: http://www.private-files.com/other/random.c.txt

I don't know how old this program is but at least as old as your question, probably somewhat older.

Anyway here's a program in C which creates files with a chi-squared test result of 0:

// ------------------------------------------------------------     
// Name: random.c  (program to create random files)
//     
// This "no-frills" program creates files with the following 
// characteristics: 
//
//    (1) Byte sequences are random (no predictability);
//    (2) Files produced are binary files; 
//    (3) File sizes are multiples of 256; 
//    (4) Files will have a chi-squared test result of 0
//        (see analyze.exe by Wenger for explanation)
//  
//              Programmer:  Scott Wenger
//                           Box 802
//                           Stevens Point, WI 54481
//                           panther@wctc.net
//
//       Note:  part of this code is from Knuth Volume II
// 
//  Enhancements and modifications of this program are left 
//  to the imagination and creativity of the programmer.
//  Check your compiler for required header files.  You may 
//  need to include the iostream header.
//
//  Random files are of potential use to cryptographers
//  for the purpose of encryption.  
//  
//  To analyze files produced by this program, see 
//  the analyze.exe program by Scott Wenger (found at
//  http://www.coredcs.com/sware.html)
// ------------------------------------------------------------


// This program works in the following way:
// The time is used to seed the random number generator.
// Using Knuth's algorithm, random numbers are generated
// in the range of 0 to 255 (corresponding to 256 ASCII chars.)
// When random numbers are generated they are marked as used and 
// are not re-used until all 256 ASCII values appear.  Characters 
// are written to disk and the process continues until the
// desired file size is reached.  Output is a random binary file
// called random.bin (placed in the root directory)
// The controlled filesize along with the placeholder feature 
// of this code forces a very high degree of randomness in 
// the output file. 

#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void init_mm();
void clear_array(); 
int  number_range(int minval, int maxval);
int  number_mm();

static int rgiState[2 + 55]; 
int place_holder[256];          // to keep track of numbers already generated

int main()
{
  mainprogram();
  return 0;
}

int mainprogram()
{
  int ch; 
  int c_used = 0;  // counter of chars in placeholder
  int done = 0; 
  int random;

  char buffer[2];

  long x;
  long byte_size = 0L;
  FILE *fp;

  clear_array();
  init_mm();  // seed random number generator

  // create a random file of length specified by user
  printf("\nrandom.exe originally by Scott Wenger");
  printf("\nThis program creates a random binary file.\n");
  printf("\nPlease specify length of random file to create (in megabytes): ");  

  scanf("%ld", &byte_size);

  while (byte_size > 1000 || byte_size <= 0 )
  {
    printf("\nWill not create files larger than a gigabyte! ");
    printf("\nPlease specify length of random file to create (in megabytes): ");
    flushall();
    scanf("%ld", &byte_size);
  }

  byte_size = byte_size * 1024 * 1024;

  if ( (fp = fopen("random.bin", "wb"))  == NULL) {
    fprintf(stderr, "\nOutput file (random.bin) could not be created.");      
    fflush(stdout);
    exit(1);
  }

  for (x = 0L; x < byte_size; x++) {

    if (c_used == 256) {
      clear_array();
      c_used = 0;
    }

    random = number_range(0, 255);    // use all ASCII values

    if ( *(place_holder + random) ) {  // already used, find another
      done = 0;
      while (!done) {
        random = number_range(0, 255);
        if ( *(place_holder + random) == 0) {
          *(place_holder + random) = 1;
          done = 1;
        }
      }         
    }
    else *(place_holder + random) = 1;  // use it and mark as used 

    c_used++;   // found next character so increment counter

    sprintf(buffer, "%c", random);  // convert ASCII value to char 
    ch = buffer[0];
    fputc(ch, fp); // write to file
  }

  fclose(fp);

  printf("\nDone. File \"random.bin\" was created (size: %ld bytes)", byte_size);
  printf("\nOutput file is in the root directory (c:\\random.bin)\n");
  return(0);
}

// ---------------------------------------------------------------------------------

void clear_array()
{
  register int x;
  for (x = 0; x < 256; x++) 
    *(place_holder + x) = 0;
}

// ---------------------------------------------------------------------------------

int number_mm()
{
    int *piState;
    int iState1;
    int iState2;
    int iRand;

    piState     = &rgiState[2];
    iState1     = piState[-2];
    iState2     = piState[-1];
    iRand       = ( piState[iState1] + piState[iState2] )
                & ( ( 1 << 30 ) - 1 );
    piState[iState1]    = iRand;

    if ( ++iState1 == 55 )  iState1 = 0;
    if ( ++iState2 == 55 )  iState2 = 0;

    piState[-2]     = iState1;
    piState[-1]     = iState2;

    return(iRand >> 6);
}

// ---------------------------------------------------------------------------------

//  Generate a random number.

int number_range( int minval, int maxval )
{
  int power, number;

  if ( ( maxval = maxval - minval + 1 ) <= 1 ) return (minval);

  for ( power = 2; power < maxval; power <<= 1 )
    ;
  while ( ( number = number_mm( ) & ( power - 1 ) ) >= maxval )
    ;
  return(minval + number);
}

// ---------------------------------------------------------------------------------

// Mitchell-Moore algorithm from Knuth Volume II. 

void init_mm( )
{
  int *piState;
  int iState;

  piState = &rgiState[2];
  piState[-2]   = 55 - 55;
  piState[-1]   = 55 - 24;
  piState[0]    = ( (int) time( NULL ) ) & ( ( 1 << 30 ) - 1 );
  piState[1]    = 1;

  for ( iState = 2; iState < 55; iState++ ) 
  {
    piState[iState] = ( piState[iState-1] + piState[iState-2] )
                      &  ( ( 1 << 30 ) - 1 );
  }
}

// -------------------- End -------------------------------------------------------
Share
Improve this answer
Follow
answered Aug 10, 2016 at 13:38
Rubenisme's user avatar
Rubenisme
78711 gold badge88 silver badges1515 bronze badges
Add a comment
1

So, i decided to add an accurate answer this time.

language is powershell. assumptions: filenames will be sequential and not random. file contents are to be cryptographically secure and unique. file location to be C:\temp\

#create a fixed size byte array for later use.  make it the required file size.
$bytearray = New-Object byte[] 2048

#create and start a stopwatch object to measure how long it all takes.
$stopwatch = [Diagnostics.Stopwatch]::StartNew()

#create a CSRNG object
$RNGObject = New-Object Security.Cryptography.RNGCryptoServiceProvider

# set up a loop to run 50000 times
0..49999 | Foreach-Object {

    # create a file stream handle with a name format 'filennnnn'
    $stream = New-Object System.IO.FileStream("c:\temp\file$("{0:D5}" -f $_)"), Create

    # and a stream writer handle
    $writer = New-Object System.IO.BinaryWriter($stream)

    # Fill our array from the CSRNG
    $RNGObject.GetNonZeroBytes($bytearray)

    # Append to the current file
    $writer.write($bytearray)

    # Close the stream
    $stream.close()

}
About
Products
For Teams
Search…
Join Stack Overflow to find the best answer to your technical question, help others answer theirs.

Home
PUBLIC
Questions
Tags
Users
Companies
COLLECTIVES
Explore Collectives
TEAMS
Stack Overflow for Teams – Start collaborating and sharing organizational knowledge. 
Generating Random Files in Windows
Asked 14 years, 3 months ago
Modified 5 months ago
Viewed 85k times
42

Does anyone have a way to generate files of random data in Windows? I would like to generate 50,000 small (2K) files as an example.

windows
Share
Improve this question
Follow
asked Feb 10, 2009 at 18:51
Jeff
2
Could you share with us whether you want text files or binary files? Could you also comment as to what programming languages you have access to (if any)? Do you have MS Office installed? Also, not very relevant, but what version of windows are you using? – 
user62572
 Feb 10, 2009 at 20:05
Add a comment
16 Answers
Sorted by:

Highest score (default)
34

You can run fsutil in a batch loop to create files of any size.

fsutil file createnew filename.extension 2000
Share
Improve this answer
Follow
answered Feb 10, 2009 at 19:01
Bogdan's user avatar
Bogdan
3,03511 gold badge2222 silver badges2020 bronze badges
I just found that utility. Didn't know it existed before. thebackroomtech.com/2009/01/16/… – 
beach
 Feb 10, 2009 at 19:04
41
However, it doesn't create random data. Just blank files. – 
beach
 Feb 10, 2009 at 19:07
And it seems to require admin permissions. Going with the powershell. – 
Mathias Mamsch
 Oct 25, 2017 at 7:21
Add a comment
21

One-liner in Powershell:

$out = new-object byte[] 1048576; (new-object Random).NextBytes($out); [IO.File]::WriteAllBytes('d:\file.bin', $out)
This is lightning fast, compared to @user188737 solution.

Share
Improve this answer
Follow
answered Sep 26, 2017 at 7:07
gwiazdorrr's user avatar
gwiazdorrr
6,16122 gold badges2727 silver badges3636 bronze badges
1
Every single file that this one liner creates is identical. Is there any way to make the content of each file different – 
Dhiwakar Ravikumar
 Apr 15, 2018 at 4:47
3
Are you sure this is the case? I tried it on my system, ran it 3 times, got 3 distinct files. The constructor for the Random type is by default based on the system time, so perhaps if you run this multiple times in very quick succession, you might get identical files. You could avoid this by creating a single Random object and then reusing it for each consecutive file: $rnd = New-Object Random; once at the top, and then $rnd.NextBytes instead of (New-Object Random).NextBytes when generating the file. – 
Jonathan Gilbert
 May 29, 2018 at 16:19
Add a comment
18

You can use PowerShell to generate cheap random data for your files:

[Byte[]] $out = @()
0..2047 | % {$out += Get-Random -Minimum 0 -Maximum 255}
[System.IO.File]::WriteAllBytes("myrandomfiletest", $out)
This uses an algorithm with a seed taken from the system clock, so don't use this for ANY serious cryptographic applications.

In addition, be wary of the performance degradation of Get-Random when increasing the size of the output file. More on this aspect here:

PowerShell random file generator too slow
Improve Powershell Performance to Generate a Random File
Share
Improve this answer
Follow
edited May 23, 2017 at 12:32
Community's user avatar
CommunityBot
111 silver badge
answered Sep 27, 2013 at 18:23
Gerrit's user avatar
Gerrit
85166 silver badges1111 bronze badges
Add a comment
16

I have been using Random Data File Creator and liking it, it creates binary files (i.e. not text files) filled with pseudo-random bits, it can quickly create very large files. To use it to create multiple small files you would need to script it, which would be very easy given it is command line.

Share
Improve this answer
Follow
edited Dec 25, 2015 at 11:57
mguassa's user avatar
mguassa
3,97122 gold badges1414 silver badges1919 bronze badges
answered Feb 5, 2010 at 19:20
David Waters's user avatar
David Waters
11.9k77 gold badges4141 silver badges7676 bronze badges
There are quite a few programs and cloud tools of this nature: raywoodcockslatest.wordpress.com/2021/08/21/dummy-files – 
Ray Woodcock
 May 17, 2022 at 14:08
Add a comment
8

Since you don't specify a language, I'll simply pick one at random. Here is a powershell script to do it:

$rootDir = 'C:\Temp\TestRandomFiles\'
$baseFile = $rootDir + "base.txt"
$desiredFileSize = 2*1KB
$fileCount = 50000
"start" | Out-File -Filepath $baseFile
While ($(Get-ChildItem -path $baseFile).Length -lt $desiredFileSize)
{
    $(Get-ChildItem -path $baseFile).Length | Out-File $baseFile -APPEND
}
for($i=1;$i -lt $fileCount;$i++)
{
    Copy-Item $baseFile "File$i.txt"
}
You'll have to change the variables to the parameters that you want of course.

Share
Improve this answer
Follow
answered Feb 10, 2009 at 19:47
EBGreen's user avatar
EBGreen
36.5k1212 gold badges6464 silver badges8484 bronze badges
1
oops...missed the random data requirement. Is that important? If so I can tweak it. – 
EBGreen
 Feb 10, 2009 at 19:48
1
If you are a PS whiz, I don't suppose you can do random data as I am keen to learn how this done! – 
Wil
 Jan 27, 2012 at 10:22 
I'm definitely not a whiz, but there are several ways. Basically you identify the data set that you want to randomize (say 0-9 and a-Z) then you randomly pick from that set to build the data for the file, then write it out to the file. If I have a chance later today, I'll alter the above code to use random data. – 
EBGreen
 Jan 27, 2012 at 15:12
@EBGreen thank You much! Best regards – 
Gennady G
 Nov 29, 2021 at 14:01
Add a comment
4

Instead of using Get-Random to generate the text as per user188737 & mguassa suggestions, I improved the speed by using GUIDs.

Function New-RandomFile {
    Param(
        $Path = '.', 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 
    (1..($FileSize/128)).foreach({-join ([guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-").SubString(1, 126) }) | set-content "$Path\$FileName"
}
This took 491 milliseconds to generate a 1mb file. Running:

New-RandomFile -FileSize 1mb
UPDATE:

I've updated my function to use a ScriptBlock, so you can replace the 'NewGuid()' method with anything you want.

In this scenario, I make 1kb chunks, since I know I'm never creating smaller files. This improved the speed of my function drastically!

Set-Content forces a NewLine at the end, which is why you need to remove 2 Characters each time you write to file. I've replaced it with [io.file]::WriteAllText() instead.

Function New-RandomFile_1kChunks {
    Param(
        $Path = (Resolve-Path '.').Path, 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 

    $Chunk = { [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-" }

    $Chunks = [math]::Ceiling($FileSize/1kb)

    [io.file]::WriteAllText("$Path\$FileName","$(-Join (1..($Chunks)).foreach({ $Chunk.Invoke() }))")

    Write-Warning "New-RandomFile: $Path\$FileName"

}
If you dont care that all chunks are random, you can simply Invoke() the generation of the 1kb chunk once.. this improves the speed drastically, but won't make the entire file random.

Function New-RandomFile_Fast {
    Param(
        $Path = (Resolve-Path '.').Path, 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 

    $Chunk = { [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-" }
    $Chunks = [math]::Ceiling($FileSize/1kb)
    $ChunkString = $Chunk.Invoke()

    [io.file]::WriteAllText("$Path\$FileName","$(-Join (1..($Chunks)).foreach({ $ChunkString }))")

    Write-Warning "New-RandomFile: $Path\$FileName"

}
Measure-Command all these changes to generate a 10mb file:

Executing New-RandomFile: 35.7688241 seconds.

Executing New-RandomFile_1kChunks: 25.1463777 seconds.

Executing New-RandomFile_Fast: 1.1626236 seconds.

Share
Improve this answer
Follow
edited Apr 3, 2017 at 23:04
answered Apr 1, 2017 at 2:39
Marc Kellerman's user avatar
Marc Kellerman
45622 silver badges1010 bronze badges
Add a comment
2

You'll have to create files in the normal way, and then populate them with randomized data, probably from a rand() function of some sort.

It really depends on your programming language. Windows itself certainly won't provide this capability.

There are a number of programming languages that could do this easily, however, including basic windows batch/CMD scripts. What language are you interested in using?

Share
Improve this answer
Follow
answered Feb 10, 2009 at 18:54
levand's user avatar
levand
8,39033 gold badges4040 silver badges5454 bronze badges
Add a comment
2

None of the answers here were cutting it for me, so here's a script which takes advantage of the Cryptography library to generate lots of random files.

This will generate files very quickly until your system's entropy is exhausted (on my PC this was about 4,000 files). After this it (and any other applications on your system that need cryptographic random numbers) will run very slowly. (In Linux terms, consider this script to use /dev/random instead of /dev/urandom)

$directory = (Get-Location).Path;
0..10000 | ForEach-Object {
    $size = 1023 * (Get-Random -Minimum 10 -Maximum 1536);
    $contents = [Byte[]]::new($size);

    $rng = [System.Security.Cryptography.RNGCryptoServiceProvider]::new();
    $rng.GetBytes($contents);

    $filename = "$directory\random$($_.ToString().PadLeft(5, '0')).txt"
    Write-Host $filename
    [System.IO.File]::WriteAllBytes($filename, $contents)
}
If you'd rather not deplete your system's entropy, replace the two $rng lines with these:

    $rng = [System.Random]::new();
    $rng.NextBytes($contents);
This will run much slower, but for large quantities of files (or larger files) it should be more reliable.

Share
Improve this answer
Follow
answered Apr 15, 2020 at 0:57
Joshua Walsh's user avatar
Joshua Walsh
1,88555 gold badges2525 silver badges5050 bronze badges
Add a comment
1

Yes, fsutil is great, but doesn't generate random data, just ASCII nulls.

I don't remember where I found this but searching on google these days I can still find it at: http://www.private-files.com/other/random.c.txt

I don't know how old this program is but at least as old as your question, probably somewhat older.

Anyway here's a program in C which creates files with a chi-squared test result of 0:

// ------------------------------------------------------------     
// Name: random.c  (program to create random files)
//     
// This "no-frills" program creates files with the following 
// characteristics: 
//
//    (1) Byte sequences are random (no predictability);
//    (2) Files produced are binary files; 
//    (3) File sizes are multiples of 256; 
//    (4) Files will have a chi-squared test result of 0
//        (see analyze.exe by Wenger for explanation)
//  
//              Programmer:  Scott Wenger
//                           Box 802
//                           Stevens Point, WI 54481
//                           panther@wctc.net
//
//       Note:  part of this code is from Knuth Volume II
// 
//  Enhancements and modifications of this program are left 
//  to the imagination and creativity of the programmer.
//  Check your compiler for required header files.  You may 
//  need to include the iostream header.
//
//  Random files are of potential use to cryptographers
//  for the purpose of encryption.  
//  
//  To analyze files produced by this program, see 
//  the analyze.exe program by Scott Wenger (found at
//  http://www.coredcs.com/sware.html)
// ------------------------------------------------------------


// This program works in the following way:
// The time is used to seed the random number generator.
// Using Knuth's algorithm, random numbers are generated
// in the range of 0 to 255 (corresponding to 256 ASCII chars.)
// When random numbers are generated they are marked as used and 
// are not re-used until all 256 ASCII values appear.  Characters 
// are written to disk and the process continues until the
// desired file size is reached.  Output is a random binary file
// called random.bin (placed in the root directory)
// The controlled filesize along with the placeholder feature 
// of this code forces a very high degree of randomness in 
// the output file. 

#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void init_mm();
void clear_array(); 
int  number_range(int minval, int maxval);
int  number_mm();

static int rgiState[2 + 55]; 
int place_holder[256];          // to keep track of numbers already generated

int main()
{
  mainprogram();
  return 0;
}

int mainprogram()
{
  int ch; 
  int c_used = 0;  // counter of chars in placeholder
  int done = 0; 
  int random;

  char buffer[2];

  long x;
  long byte_size = 0L;
  FILE *fp;

  clear_array();
  init_mm();  // seed random number generator

  // create a random file of length specified by user
  printf("\nrandom.exe originally by Scott Wenger");
  printf("\nThis program creates a random binary file.\n");
  printf("\nPlease specify length of random file to create (in megabytes): ");  

  scanf("%ld", &byte_size);

  while (byte_size > 1000 || byte_size <= 0 )
  {
    printf("\nWill not create files larger than a gigabyte! ");
    printf("\nPlease specify length of random file to create (in megabytes): ");
    flushall();
    scanf("%ld", &byte_size);
  }

  byte_size = byte_size * 1024 * 1024;

  if ( (fp = fopen("random.bin", "wb"))  == NULL) {
    fprintf(stderr, "\nOutput file (random.bin) could not be created.");      
    fflush(stdout);
    exit(1);
  }

  for (x = 0L; x < byte_size; x++) {

    if (c_used == 256) {
      clear_array();
      c_used = 0;
    }

    random = number_range(0, 255);    // use all ASCII values

    if ( *(place_holder + random) ) {  // already used, find another
      done = 0;
      while (!done) {
        random = number_range(0, 255);
        if ( *(place_holder + random) == 0) {
          *(place_holder + random) = 1;
          done = 1;
        }
      }         
    }
    else *(place_holder + random) = 1;  // use it and mark as used 

    c_used++;   // found next character so increment counter

    sprintf(buffer, "%c", random);  // convert ASCII value to char 
    ch = buffer[0];
    fputc(ch, fp); // write to file
  }

  fclose(fp);

  printf("\nDone. File \"random.bin\" was created (size: %ld bytes)", byte_size);
  printf("\nOutput file is in the root directory (c:\\random.bin)\n");
  return(0);
}

// ---------------------------------------------------------------------------------

void clear_array()
{
  register int x;
  for (x = 0; x < 256; x++) 
    *(place_holder + x) = 0;
}

// ---------------------------------------------------------------------------------

int number_mm()
{
    int *piState;
    int iState1;
    int iState2;
    int iRand;

    piState     = &rgiState[2];
    iState1     = piState[-2];
    iState2     = piState[-1];
    iRand       = ( piState[iState1] + piState[iState2] )
                & ( ( 1 << 30 ) - 1 );
    piState[iState1]    = iRand;

    if ( ++iState1 == 55 )  iState1 = 0;
    if ( ++iState2 == 55 )  iState2 = 0;

    piState[-2]     = iState1;
    piState[-1]     = iState2;

    return(iRand >> 6);
}

// ---------------------------------------------------------------------------------

//  Generate a random number.

int number_range( int minval, int maxval )
{
  int power, number;

  if ( ( maxval = maxval - minval + 1 ) <= 1 ) return (minval);

  for ( power = 2; power < maxval; power <<= 1 )
    ;
  while ( ( number = number_mm( ) & ( power - 1 ) ) >= maxval )
    ;
  return(minval + number);
}

// ---------------------------------------------------------------------------------

// Mitchell-Moore algorithm from Knuth Volume II. 

void init_mm( )
{
  int *piState;
  int iState;

  piState = &rgiState[2];
  piState[-2]   = 55 - 55;
  piState[-1]   = 55 - 24;
  piState[0]    = ( (int) time( NULL ) ) & ( ( 1 << 30 ) - 1 );
  piState[1]    = 1;

  for ( iState = 2; iState < 55; iState++ ) 
  {
    piState[iState] = ( piState[iState-1] + piState[iState-2] )
                      &  ( ( 1 << 30 ) - 1 );
  }
}

// -------------------- End -------------------------------------------------------
Share
Improve this answer
Follow
answered Aug 10, 2016 at 13:38
Rubenisme's user avatar
Rubenisme
78711 gold badge88 silver badges1515 bronze badges
Add a comment
1

So, i decided to add an accurate answer this time.

language is powershell. assumptions: filenames will be sequential and not random. file contents are to be cryptographically secure and unique. file location to be C:\temp\

#create a fixed size byte array for later use.  make it the required file size.
$bytearray = New-Object byte[] 2048

#create and start a stopwatch object to measure how long it all takes.
$stopwatch = [Diagnostics.Stopwatch]::StartNew()

#create a CSRNG object
$RNGObject = New-Object Security.Cryptography.RNGCryptoServiceProvider

# set up a loop to run 50000 times
0..49999 | Foreach-Object {

    # create a file stream handle with a name format 'filennnnn'
    $stream = New-Object System.IO.FileStream("c:\temp\file$("{0:D5}" -f $_)"), Create

    # and a stream writer handle
    $writer = New-Object System.IO.BinaryWriter($stream)

    # Fill our array from the CSRNG
    $RNGObject.GetNonZeroBytes($bytearray)

    # Append to the current file
    $writer.write($bytearray)

    # Close the stream
    $stream.close()

}
About
Products
For Teams
Search…
Join Stack Overflow to find the best answer to your technical question, help others answer theirs.

Home
PUBLIC
Questions
Tags
Users
Companies
COLLECTIVES
Explore Collectives
TEAMS
Stack Overflow for Teams – Start collaborating and sharing organizational knowledge. 
Generating Random Files in Windows
Asked 14 years, 3 months ago
Modified 5 months ago
Viewed 85k times
42

Does anyone have a way to generate files of random data in Windows? I would like to generate 50,000 small (2K) files as an example.

windows
Share
Improve this question
Follow
asked Feb 10, 2009 at 18:51
Jeff
2
Could you share with us whether you want text files or binary files? Could you also comment as to what programming languages you have access to (if any)? Do you have MS Office installed? Also, not very relevant, but what version of windows are you using? – 
user62572
 Feb 10, 2009 at 20:05
Add a comment
16 Answers
Sorted by:

Highest score (default)
34

You can run fsutil in a batch loop to create files of any size.

fsutil file createnew filename.extension 2000
Share
Improve this answer
Follow
answered Feb 10, 2009 at 19:01
Bogdan's user avatar
Bogdan
3,03511 gold badge2222 silver badges2020 bronze badges
I just found that utility. Didn't know it existed before. thebackroomtech.com/2009/01/16/… – 
beach
 Feb 10, 2009 at 19:04
41
However, it doesn't create random data. Just blank files. – 
beach
 Feb 10, 2009 at 19:07
And it seems to require admin permissions. Going with the powershell. – 
Mathias Mamsch
 Oct 25, 2017 at 7:21
Add a comment
21

One-liner in Powershell:

$out = new-object byte[] 1048576; (new-object Random).NextBytes($out); [IO.File]::WriteAllBytes('d:\file.bin', $out)
This is lightning fast, compared to @user188737 solution.

Share
Improve this answer
Follow
answered Sep 26, 2017 at 7:07
gwiazdorrr's user avatar
gwiazdorrr
6,16122 gold badges2727 silver badges3636 bronze badges
1
Every single file that this one liner creates is identical. Is there any way to make the content of each file different – 
Dhiwakar Ravikumar
 Apr 15, 2018 at 4:47
3
Are you sure this is the case? I tried it on my system, ran it 3 times, got 3 distinct files. The constructor for the Random type is by default based on the system time, so perhaps if you run this multiple times in very quick succession, you might get identical files. You could avoid this by creating a single Random object and then reusing it for each consecutive file: $rnd = New-Object Random; once at the top, and then $rnd.NextBytes instead of (New-Object Random).NextBytes when generating the file. – 
Jonathan Gilbert
 May 29, 2018 at 16:19
Add a comment
18

You can use PowerShell to generate cheap random data for your files:

[Byte[]] $out = @()
0..2047 | % {$out += Get-Random -Minimum 0 -Maximum 255}
[System.IO.File]::WriteAllBytes("myrandomfiletest", $out)
This uses an algorithm with a seed taken from the system clock, so don't use this for ANY serious cryptographic applications.

In addition, be wary of the performance degradation of Get-Random when increasing the size of the output file. More on this aspect here:

PowerShell random file generator too slow
Improve Powershell Performance to Generate a Random File
Share
Improve this answer
Follow
edited May 23, 2017 at 12:32
Community's user avatar
CommunityBot
111 silver badge
answered Sep 27, 2013 at 18:23
Gerrit's user avatar
Gerrit
85166 silver badges1111 bronze badges
Add a comment
16

I have been using Random Data File Creator and liking it, it creates binary files (i.e. not text files) filled with pseudo-random bits, it can quickly create very large files. To use it to create multiple small files you would need to script it, which would be very easy given it is command line.

Share
Improve this answer
Follow
edited Dec 25, 2015 at 11:57
mguassa's user avatar
mguassa
3,97122 gold badges1414 silver badges1919 bronze badges
answered Feb 5, 2010 at 19:20
David Waters's user avatar
David Waters
11.9k77 gold badges4141 silver badges7676 bronze badges
There are quite a few programs and cloud tools of this nature: raywoodcockslatest.wordpress.com/2021/08/21/dummy-files – 
Ray Woodcock
 May 17, 2022 at 14:08
Add a comment
8

Since you don't specify a language, I'll simply pick one at random. Here is a powershell script to do it:

$rootDir = 'C:\Temp\TestRandomFiles\'
$baseFile = $rootDir + "base.txt"
$desiredFileSize = 2*1KB
$fileCount = 50000
"start" | Out-File -Filepath $baseFile
While ($(Get-ChildItem -path $baseFile).Length -lt $desiredFileSize)
{
    $(Get-ChildItem -path $baseFile).Length | Out-File $baseFile -APPEND
}
for($i=1;$i -lt $fileCount;$i++)
{
    Copy-Item $baseFile "File$i.txt"
}
You'll have to change the variables to the parameters that you want of course.

Share
Improve this answer
Follow
answered Feb 10, 2009 at 19:47
EBGreen's user avatar
EBGreen
36.5k1212 gold badges6464 silver badges8484 bronze badges
1
oops...missed the random data requirement. Is that important? If so I can tweak it. – 
EBGreen
 Feb 10, 2009 at 19:48
1
If you are a PS whiz, I don't suppose you can do random data as I am keen to learn how this done! – 
Wil
 Jan 27, 2012 at 10:22 
I'm definitely not a whiz, but there are several ways. Basically you identify the data set that you want to randomize (say 0-9 and a-Z) then you randomly pick from that set to build the data for the file, then write it out to the file. If I have a chance later today, I'll alter the above code to use random data. – 
EBGreen
 Jan 27, 2012 at 15:12
@EBGreen thank You much! Best regards – 
Gennady G
 Nov 29, 2021 at 14:01
Add a comment
4

Instead of using Get-Random to generate the text as per user188737 & mguassa suggestions, I improved the speed by using GUIDs.

Function New-RandomFile {
    Param(
        $Path = '.', 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 
    (1..($FileSize/128)).foreach({-join ([guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-").SubString(1, 126) }) | set-content "$Path\$FileName"
}
This took 491 milliseconds to generate a 1mb file. Running:

New-RandomFile -FileSize 1mb
UPDATE:

I've updated my function to use a ScriptBlock, so you can replace the 'NewGuid()' method with anything you want.

In this scenario, I make 1kb chunks, since I know I'm never creating smaller files. This improved the speed of my function drastically!

Set-Content forces a NewLine at the end, which is why you need to remove 2 Characters each time you write to file. I've replaced it with [io.file]::WriteAllText() instead.

Function New-RandomFile_1kChunks {
    Param(
        $Path = (Resolve-Path '.').Path, 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 

    $Chunk = { [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-" }

    $Chunks = [math]::Ceiling($FileSize/1kb)

    [io.file]::WriteAllText("$Path\$FileName","$(-Join (1..($Chunks)).foreach({ $Chunk.Invoke() }))")

    Write-Warning "New-RandomFile: $Path\$FileName"

}
If you dont care that all chunks are random, you can simply Invoke() the generation of the 1kb chunk once.. this improves the speed drastically, but won't make the entire file random.

Function New-RandomFile_Fast {
    Param(
        $Path = (Resolve-Path '.').Path, 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 

    $Chunk = { [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-" }
    $Chunks = [math]::Ceiling($FileSize/1kb)
    $ChunkString = $Chunk.Invoke()

    [io.file]::WriteAllText("$Path\$FileName","$(-Join (1..($Chunks)).foreach({ $ChunkString }))")

    Write-Warning "New-RandomFile: $Path\$FileName"

}
Measure-Command all these changes to generate a 10mb file:

Executing New-RandomFile: 35.7688241 seconds.

Executing New-RandomFile_1kChunks: 25.1463777 seconds.

Executing New-RandomFile_Fast: 1.1626236 seconds.

Share
Improve this answer
Follow
edited Apr 3, 2017 at 23:04
answered Apr 1, 2017 at 2:39
Marc Kellerman's user avatar
Marc Kellerman
45622 silver badges1010 bronze badges
Add a comment
2

You'll have to create files in the normal way, and then populate them with randomized data, probably from a rand() function of some sort.

It really depends on your programming language. Windows itself certainly won't provide this capability.

There are a number of programming languages that could do this easily, however, including basic windows batch/CMD scripts. What language are you interested in using?

Share
Improve this answer
Follow
answered Feb 10, 2009 at 18:54
levand's user avatar
levand
8,39033 gold badges4040 silver badges5454 bronze badges
Add a comment
2

None of the answers here were cutting it for me, so here's a script which takes advantage of the Cryptography library to generate lots of random files.

This will generate files very quickly until your system's entropy is exhausted (on my PC this was about 4,000 files). After this it (and any other applications on your system that need cryptographic random numbers) will run very slowly. (In Linux terms, consider this script to use /dev/random instead of /dev/urandom)

$directory = (Get-Location).Path;
0..10000 | ForEach-Object {
    $size = 1023 * (Get-Random -Minimum 10 -Maximum 1536);
    $contents = [Byte[]]::new($size);

    $rng = [System.Security.Cryptography.RNGCryptoServiceProvider]::new();
    $rng.GetBytes($contents);

    $filename = "$directory\random$($_.ToString().PadLeft(5, '0')).txt"
    Write-Host $filename
    [System.IO.File]::WriteAllBytes($filename, $contents)
}
If you'd rather not deplete your system's entropy, replace the two $rng lines with these:

    $rng = [System.Random]::new();
    $rng.NextBytes($contents);
This will run much slower, but for large quantities of files (or larger files) it should be more reliable.

Share
Improve this answer
Follow
answered Apr 15, 2020 at 0:57
Joshua Walsh's user avatar
Joshua Walsh
1,88555 gold badges2525 silver badges5050 bronze badges
Add a comment
1

Yes, fsutil is great, but doesn't generate random data, just ASCII nulls.

I don't remember where I found this but searching on google these days I can still find it at: http://www.private-files.com/other/random.c.txt

I don't know how old this program is but at least as old as your question, probably somewhat older.

Anyway here's a program in C which creates files with a chi-squared test result of 0:

// ------------------------------------------------------------     
// Name: random.c  (program to create random files)
//     
// This "no-frills" program creates files with the following 
// characteristics: 
//
//    (1) Byte sequences are random (no predictability);
//    (2) Files produced are binary files; 
//    (3) File sizes are multiples of 256; 
//    (4) Files will have a chi-squared test result of 0
//        (see analyze.exe by Wenger for explanation)
//  
//              Programmer:  Scott Wenger
//                           Box 802
//                           Stevens Point, WI 54481
//                           panther@wctc.net
//
//       Note:  part of this code is from Knuth Volume II
// 
//  Enhancements and modifications of this program are left 
//  to the imagination and creativity of the programmer.
//  Check your compiler for required header files.  You may 
//  need to include the iostream header.
//
//  Random files are of potential use to cryptographers
//  for the purpose of encryption.  
//  
//  To analyze files produced by this program, see 
//  the analyze.exe program by Scott Wenger (found at
//  http://www.coredcs.com/sware.html)
// ------------------------------------------------------------


// This program works in the following way:
// The time is used to seed the random number generator.
// Using Knuth's algorithm, random numbers are generated
// in the range of 0 to 255 (corresponding to 256 ASCII chars.)
// When random numbers are generated they are marked as used and 
// are not re-used until all 256 ASCII values appear.  Characters 
// are written to disk and the process continues until the
// desired file size is reached.  Output is a random binary file
// called random.bin (placed in the root directory)
// The controlled filesize along with the placeholder feature 
// of this code forces a very high degree of randomness in 
// the output file. 

#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void init_mm();
void clear_array(); 
int  number_range(int minval, int maxval);
int  number_mm();

static int rgiState[2 + 55]; 
int place_holder[256];          // to keep track of numbers already generated

int main()
{
  mainprogram();
  return 0;
}

int mainprogram()
{
  int ch; 
  int c_used = 0;  // counter of chars in placeholder
  int done = 0; 
  int random;

  char buffer[2];

  long x;
  long byte_size = 0L;
  FILE *fp;

  clear_array();
  init_mm();  // seed random number generator

  // create a random file of length specified by user
  printf("\nrandom.exe originally by Scott Wenger");
  printf("\nThis program creates a random binary file.\n");
  printf("\nPlease specify length of random file to create (in megabytes): ");  

  scanf("%ld", &byte_size);

  while (byte_size > 1000 || byte_size <= 0 )
  {
    printf("\nWill not create files larger than a gigabyte! ");
    printf("\nPlease specify length of random file to create (in megabytes): ");
    flushall();
    scanf("%ld", &byte_size);
  }

  byte_size = byte_size * 1024 * 1024;

  if ( (fp = fopen("random.bin", "wb"))  == NULL) {
    fprintf(stderr, "\nOutput file (random.bin) could not be created.");      
    fflush(stdout);
    exit(1);
  }

  for (x = 0L; x < byte_size; x++) {

    if (c_used == 256) {
      clear_array();
      c_used = 0;
    }

    random = number_range(0, 255);    // use all ASCII values

    if ( *(place_holder + random) ) {  // already used, find another
      done = 0;
      while (!done) {
        random = number_range(0, 255);
        if ( *(place_holder + random) == 0) {
          *(place_holder + random) = 1;
          done = 1;
        }
      }         
    }
    else *(place_holder + random) = 1;  // use it and mark as used 

    c_used++;   // found next character so increment counter

    sprintf(buffer, "%c", random);  // convert ASCII value to char 
    ch = buffer[0];
    fputc(ch, fp); // write to file
  }

  fclose(fp);

  printf("\nDone. File \"random.bin\" was created (size: %ld bytes)", byte_size);
  printf("\nOutput file is in the root directory (c:\\random.bin)\n");
  return(0);
}

// ---------------------------------------------------------------------------------

void clear_array()
{
  register int x;
  for (x = 0; x < 256; x++) 
    *(place_holder + x) = 0;
}

// ---------------------------------------------------------------------------------

int number_mm()
{
    int *piState;
    int iState1;
    int iState2;
    int iRand;

    piState     = &rgiState[2];
    iState1     = piState[-2];
    iState2     = piState[-1];
    iRand       = ( piState[iState1] + piState[iState2] )
                & ( ( 1 << 30 ) - 1 );
    piState[iState1]    = iRand;

    if ( ++iState1 == 55 )  iState1 = 0;
    if ( ++iState2 == 55 )  iState2 = 0;

    piState[-2]     = iState1;
    piState[-1]     = iState2;

    return(iRand >> 6);
}

// ---------------------------------------------------------------------------------

//  Generate a random number.

int number_range( int minval, int maxval )
{
  int power, number;

  if ( ( maxval = maxval - minval + 1 ) <= 1 ) return (minval);

  for ( power = 2; power < maxval; power <<= 1 )
    ;
  while ( ( number = number_mm( ) & ( power - 1 ) ) >= maxval )
    ;
  return(minval + number);
}

// ---------------------------------------------------------------------------------

// Mitchell-Moore algorithm from Knuth Volume II. 

void init_mm( )
{
  int *piState;
  int iState;

  piState = &rgiState[2];
  piState[-2]   = 55 - 55;
  piState[-1]   = 55 - 24;
  piState[0]    = ( (int) time( NULL ) ) & ( ( 1 << 30 ) - 1 );
  piState[1]    = 1;

  for ( iState = 2; iState < 55; iState++ ) 
  {
    piState[iState] = ( piState[iState-1] + piState[iState-2] )
                      &  ( ( 1 << 30 ) - 1 );
  }
}

// -------------------- End -------------------------------------------------------
Share
Improve this answer
Follow
answered Aug 10, 2016 at 13:38
Rubenisme's user avatar
Rubenisme
78711 gold badge88 silver badges1515 bronze badges
Add a comment
1

So, i decided to add an accurate answer this time.

language is powershell. assumptions: filenames will be sequential and not random. file contents are to be cryptographically secure and unique. file location to be C:\temp\

#create a fixed size byte array for later use.  make it the required file size.
$bytearray = New-Object byte[] 2048

#create and start a stopwatch object to measure how long it all takes.
$stopwatch = [Diagnostics.Stopwatch]::StartNew()

#create a CSRNG object
$RNGObject = New-Object Security.Cryptography.RNGCryptoServiceProvider

# set up a loop to run 50000 times
0..49999 | Foreach-Object {

    # create a file stream handle with a name format 'filennnnn'
    $stream = New-Object System.IO.FileStream("c:\temp\file$("{0:D5}" -f $_)"), Create

    # and a stream writer handle
    $writer = New-Object System.IO.BinaryWriter($stream)

    # Fill our array from the CSRNG
    $RNGObject.GetNonZeroBytes($bytearray)

    # Append to the current file
    $writer.write($bytearray)

    # Close the stream
    $stream.close()

}
About
Products
For Teams
Search…
Join Stack Overflow to find the best answer to your technical question, help others answer theirs.

Home
PUBLIC
Questions
Tags
Users
Companies
COLLECTIVES
Explore Collectives
TEAMS
Stack Overflow for Teams – Start collaborating and sharing organizational knowledge. 
Generating Random Files in Windows
Asked 14 years, 3 months ago
Modified 5 months ago
Viewed 85k times
42

Does anyone have a way to generate files of random data in Windows? I would like to generate 50,000 small (2K) files as an example.

windows
Share
Improve this question
Follow
asked Feb 10, 2009 at 18:51
Jeff
2
Could you share with us whether you want text files or binary files? Could you also comment as to what programming languages you have access to (if any)? Do you have MS Office installed? Also, not very relevant, but what version of windows are you using? – 
user62572
 Feb 10, 2009 at 20:05
Add a comment
16 Answers
Sorted by:

Highest score (default)
34

You can run fsutil in a batch loop to create files of any size.

fsutil file createnew filename.extension 2000
Share
Improve this answer
Follow
answered Feb 10, 2009 at 19:01
Bogdan's user avatar
Bogdan
3,03511 gold badge2222 silver badges2020 bronze badges
I just found that utility. Didn't know it existed before. thebackroomtech.com/2009/01/16/… – 
beach
 Feb 10, 2009 at 19:04
41
However, it doesn't create random data. Just blank files. – 
beach
 Feb 10, 2009 at 19:07
And it seems to require admin permissions. Going with the powershell. – 
Mathias Mamsch
 Oct 25, 2017 at 7:21
Add a comment
21

One-liner in Powershell:

$out = new-object byte[] 1048576; (new-object Random).NextBytes($out); [IO.File]::WriteAllBytes('d:\file.bin', $out)
This is lightning fast, compared to @user188737 solution.

Share
Improve this answer
Follow
answered Sep 26, 2017 at 7:07
gwiazdorrr's user avatar
gwiazdorrr
6,16122 gold badges2727 silver badges3636 bronze badges
1
Every single file that this one liner creates is identical. Is there any way to make the content of each file different – 
Dhiwakar Ravikumar
 Apr 15, 2018 at 4:47
3
Are you sure this is the case? I tried it on my system, ran it 3 times, got 3 distinct files. The constructor for the Random type is by default based on the system time, so perhaps if you run this multiple times in very quick succession, you might get identical files. You could avoid this by creating a single Random object and then reusing it for each consecutive file: $rnd = New-Object Random; once at the top, and then $rnd.NextBytes instead of (New-Object Random).NextBytes when generating the file. – 
Jonathan Gilbert
 May 29, 2018 at 16:19
Add a comment
18

You can use PowerShell to generate cheap random data for your files:

[Byte[]] $out = @()
0..2047 | % {$out += Get-Random -Minimum 0 -Maximum 255}
[System.IO.File]::WriteAllBytes("myrandomfiletest", $out)
This uses an algorithm with a seed taken from the system clock, so don't use this for ANY serious cryptographic applications.

In addition, be wary of the performance degradation of Get-Random when increasing the size of the output file. More on this aspect here:

PowerShell random file generator too slow
Improve Powershell Performance to Generate a Random File
Share
Improve this answer
Follow
edited May 23, 2017 at 12:32
Community's user avatar
CommunityBot
111 silver badge
answered Sep 27, 2013 at 18:23
Gerrit's user avatar
Gerrit
85166 silver badges1111 bronze badges
Add a comment
16

I have been using Random Data File Creator and liking it, it creates binary files (i.e. not text files) filled with pseudo-random bits, it can quickly create very large files. To use it to create multiple small files you would need to script it, which would be very easy given it is command line.

Share
Improve this answer
Follow
edited Dec 25, 2015 at 11:57
mguassa's user avatar
mguassa
3,97122 gold badges1414 silver badges1919 bronze badges
answered Feb 5, 2010 at 19:20
David Waters's user avatar
David Waters
11.9k77 gold badges4141 silver badges7676 bronze badges
There are quite a few programs and cloud tools of this nature: raywoodcockslatest.wordpress.com/2021/08/21/dummy-files – 
Ray Woodcock
 May 17, 2022 at 14:08
Add a comment
8

Since you don't specify a language, I'll simply pick one at random. Here is a powershell script to do it:

$rootDir = 'C:\Temp\TestRandomFiles\'
$baseFile = $rootDir + "base.txt"
$desiredFileSize = 2*1KB
$fileCount = 50000
"start" | Out-File -Filepath $baseFile
While ($(Get-ChildItem -path $baseFile).Length -lt $desiredFileSize)
{
    $(Get-ChildItem -path $baseFile).Length | Out-File $baseFile -APPEND
}
for($i=1;$i -lt $fileCount;$i++)
{
    Copy-Item $baseFile "File$i.txt"
}
You'll have to change the variables to the parameters that you want of course.

Share
Improve this answer
Follow
answered Feb 10, 2009 at 19:47
EBGreen's user avatar
EBGreen
36.5k1212 gold badges6464 silver badges8484 bronze badges
1
oops...missed the random data requirement. Is that important? If so I can tweak it. – 
EBGreen
 Feb 10, 2009 at 19:48
1
If you are a PS whiz, I don't suppose you can do random data as I am keen to learn how this done! – 
Wil
 Jan 27, 2012 at 10:22 
I'm definitely not a whiz, but there are several ways. Basically you identify the data set that you want to randomize (say 0-9 and a-Z) then you randomly pick from that set to build the data for the file, then write it out to the file. If I have a chance later today, I'll alter the above code to use random data. – 
EBGreen
 Jan 27, 2012 at 15:12
@EBGreen thank You much! Best regards – 
Gennady G
 Nov 29, 2021 at 14:01
Add a comment
4

Instead of using Get-Random to generate the text as per user188737 & mguassa suggestions, I improved the speed by using GUIDs.

Function New-RandomFile {
    Param(
        $Path = '.', 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 
    (1..($FileSize/128)).foreach({-join ([guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-").SubString(1, 126) }) | set-content "$Path\$FileName"
}
This took 491 milliseconds to generate a 1mb file. Running:

New-RandomFile -FileSize 1mb
UPDATE:

I've updated my function to use a ScriptBlock, so you can replace the 'NewGuid()' method with anything you want.

In this scenario, I make 1kb chunks, since I know I'm never creating smaller files. This improved the speed of my function drastically!

Set-Content forces a NewLine at the end, which is why you need to remove 2 Characters each time you write to file. I've replaced it with [io.file]::WriteAllText() instead.

Function New-RandomFile_1kChunks {
    Param(
        $Path = (Resolve-Path '.').Path, 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 

    $Chunk = { [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-" }

    $Chunks = [math]::Ceiling($FileSize/1kb)

    [io.file]::WriteAllText("$Path\$FileName","$(-Join (1..($Chunks)).foreach({ $Chunk.Invoke() }))")

    Write-Warning "New-RandomFile: $Path\$FileName"

}
If you dont care that all chunks are random, you can simply Invoke() the generation of the 1kb chunk once.. this improves the speed drastically, but won't make the entire file random.

Function New-RandomFile_Fast {
    Param(
        $Path = (Resolve-Path '.').Path, 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 

    $Chunk = { [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-" }
    $Chunks = [math]::Ceiling($FileSize/1kb)
    $ChunkString = $Chunk.Invoke()

    [io.file]::WriteAllText("$Path\$FileName","$(-Join (1..($Chunks)).foreach({ $ChunkString }))")

    Write-Warning "New-RandomFile: $Path\$FileName"

}
Measure-Command all these changes to generate a 10mb file:

Executing New-RandomFile: 35.7688241 seconds.

Executing New-RandomFile_1kChunks: 25.1463777 seconds.

Executing New-RandomFile_Fast: 1.1626236 seconds.

Share
Improve this answer
Follow
edited Apr 3, 2017 at 23:04
answered Apr 1, 2017 at 2:39
Marc Kellerman's user avatar
Marc Kellerman
45622 silver badges1010 bronze badges
Add a comment
2

You'll have to create files in the normal way, and then populate them with randomized data, probably from a rand() function of some sort.

It really depends on your programming language. Windows itself certainly won't provide this capability.

There are a number of programming languages that could do this easily, however, including basic windows batch/CMD scripts. What language are you interested in using?

Share
Improve this answer
Follow
answered Feb 10, 2009 at 18:54
levand's user avatar
levand
8,39033 gold badges4040 silver badges5454 bronze badges
Add a comment
2

None of the answers here were cutting it for me, so here's a script which takes advantage of the Cryptography library to generate lots of random files.

This will generate files very quickly until your system's entropy is exhausted (on my PC this was about 4,000 files). After this it (and any other applications on your system that need cryptographic random numbers) will run very slowly. (In Linux terms, consider this script to use /dev/random instead of /dev/urandom)

$directory = (Get-Location).Path;
0..10000 | ForEach-Object {
    $size = 1023 * (Get-Random -Minimum 10 -Maximum 1536);
    $contents = [Byte[]]::new($size);

    $rng = [System.Security.Cryptography.RNGCryptoServiceProvider]::new();
    $rng.GetBytes($contents);

    $filename = "$directory\random$($_.ToString().PadLeft(5, '0')).txt"
    Write-Host $filename
    [System.IO.File]::WriteAllBytes($filename, $contents)
}
If you'd rather not deplete your system's entropy, replace the two $rng lines with these:

    $rng = [System.Random]::new();
    $rng.NextBytes($contents);
This will run much slower, but for large quantities of files (or larger files) it should be more reliable.

Share
Improve this answer
Follow
answered Apr 15, 2020 at 0:57
Joshua Walsh's user avatar
Joshua Walsh
1,88555 gold badges2525 silver badges5050 bronze badges
Add a comment
1

Yes, fsutil is great, but doesn't generate random data, just ASCII nulls.

I don't remember where I found this but searching on google these days I can still find it at: http://www.private-files.com/other/random.c.txt

I don't know how old this program is but at least as old as your question, probably somewhat older.

Anyway here's a program in C which creates files with a chi-squared test result of 0:

// ------------------------------------------------------------     
// Name: random.c  (program to create random files)
//     
// This "no-frills" program creates files with the following 
// characteristics: 
//
//    (1) Byte sequences are random (no predictability);
//    (2) Files produced are binary files; 
//    (3) File sizes are multiples of 256; 
//    (4) Files will have a chi-squared test result of 0
//        (see analyze.exe by Wenger for explanation)
//  
//              Programmer:  Scott Wenger
//                           Box 802
//                           Stevens Point, WI 54481
//                           panther@wctc.net
//
//       Note:  part of this code is from Knuth Volume II
// 
//  Enhancements and modifications of this program are left 
//  to the imagination and creativity of the programmer.
//  Check your compiler for required header files.  You may 
//  need to include the iostream header.
//
//  Random files are of potential use to cryptographers
//  for the purpose of encryption.  
//  
//  To analyze files produced by this program, see 
//  the analyze.exe program by Scott Wenger (found at
//  http://www.coredcs.com/sware.html)
// ------------------------------------------------------------


// This program works in the following way:
// The time is used to seed the random number generator.
// Using Knuth's algorithm, random numbers are generated
// in the range of 0 to 255 (corresponding to 256 ASCII chars.)
// When random numbers are generated they are marked as used and 
// are not re-used until all 256 ASCII values appear.  Characters 
// are written to disk and the process continues until the
// desired file size is reached.  Output is a random binary file
// called random.bin (placed in the root directory)
// The controlled filesize along with the placeholder feature 
// of this code forces a very high degree of randomness in 
// the output file. 

#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void init_mm();
void clear_array(); 
int  number_range(int minval, int maxval);
int  number_mm();

static int rgiState[2 + 55]; 
int place_holder[256];          // to keep track of numbers already generated

int main()
{
  mainprogram();
  return 0;
}

int mainprogram()
{
  int ch; 
  int c_used = 0;  // counter of chars in placeholder
  int done = 0; 
  int random;

  char buffer[2];

  long x;
  long byte_size = 0L;
  FILE *fp;

  clear_array();
  init_mm();  // seed random number generator

  // create a random file of length specified by user
  printf("\nrandom.exe originally by Scott Wenger");
  printf("\nThis program creates a random binary file.\n");
  printf("\nPlease specify length of random file to create (in megabytes): ");  

  scanf("%ld", &byte_size);

  while (byte_size > 1000 || byte_size <= 0 )
  {
    printf("\nWill not create files larger than a gigabyte! ");
    printf("\nPlease specify length of random file to create (in megabytes): ");
    flushall();
    scanf("%ld", &byte_size);
  }

  byte_size = byte_size * 1024 * 1024;

  if ( (fp = fopen("random.bin", "wb"))  == NULL) {
    fprintf(stderr, "\nOutput file (random.bin) could not be created.");      
    fflush(stdout);
    exit(1);
  }

  for (x = 0L; x < byte_size; x++) {

    if (c_used == 256) {
      clear_array();
      c_used = 0;
    }

    random = number_range(0, 255);    // use all ASCII values

    if ( *(place_holder + random) ) {  // already used, find another
      done = 0;
      while (!done) {
        random = number_range(0, 255);
        if ( *(place_holder + random) == 0) {
          *(place_holder + random) = 1;
          done = 1;
        }
      }         
    }
    else *(place_holder + random) = 1;  // use it and mark as used 

    c_used++;   // found next character so increment counter

    sprintf(buffer, "%c", random);  // convert ASCII value to char 
    ch = buffer[0];
    fputc(ch, fp); // write to file
  }

  fclose(fp);

  printf("\nDone. File \"random.bin\" was created (size: %ld bytes)", byte_size);
  printf("\nOutput file is in the root directory (c:\\random.bin)\n");
  return(0);
}

// ---------------------------------------------------------------------------------

void clear_array()
{
  register int x;
  for (x = 0; x < 256; x++) 
    *(place_holder + x) = 0;
}

// ---------------------------------------------------------------------------------

int number_mm()
{
    int *piState;
    int iState1;
    int iState2;
    int iRand;

    piState     = &rgiState[2];
    iState1     = piState[-2];
    iState2     = piState[-1];
    iRand       = ( piState[iState1] + piState[iState2] )
                & ( ( 1 << 30 ) - 1 );
    piState[iState1]    = iRand;

    if ( ++iState1 == 55 )  iState1 = 0;
    if ( ++iState2 == 55 )  iState2 = 0;

    piState[-2]     = iState1;
    piState[-1]     = iState2;

    return(iRand >> 6);
}

// ---------------------------------------------------------------------------------

//  Generate a random number.

int number_range( int minval, int maxval )
{
  int power, number;

  if ( ( maxval = maxval - minval + 1 ) <= 1 ) return (minval);

  for ( power = 2; power < maxval; power <<= 1 )
    ;
  while ( ( number = number_mm( ) & ( power - 1 ) ) >= maxval )
    ;
  return(minval + number);
}

// ---------------------------------------------------------------------------------

// Mitchell-Moore algorithm from Knuth Volume II. 

void init_mm( )
{
  int *piState;
  int iState;

  piState = &rgiState[2];
  piState[-2]   = 55 - 55;
  piState[-1]   = 55 - 24;
  piState[0]    = ( (int) time( NULL ) ) & ( ( 1 << 30 ) - 1 );
  piState[1]    = 1;

  for ( iState = 2; iState < 55; iState++ ) 
  {
    piState[iState] = ( piState[iState-1] + piState[iState-2] )
                      &  ( ( 1 << 30 ) - 1 );
  }
}

// -------------------- End -------------------------------------------------------
Share
Improve this answer
Follow
answered Aug 10, 2016 at 13:38
Rubenisme's user avatar
Rubenisme
78711 gold badge88 silver badges1515 bronze badges
Add a comment
1

So, i decided to add an accurate answer this time.

language is powershell. assumptions: filenames will be sequential and not random. file contents are to be cryptographically secure and unique. file location to be C:\temp\

#create a fixed size byte array for later use.  make it the required file size.
$bytearray = New-Object byte[] 2048

#create and start a stopwatch object to measure how long it all takes.
$stopwatch = [Diagnostics.Stopwatch]::StartNew()

#create a CSRNG object
$RNGObject = New-Object Security.Cryptography.RNGCryptoServiceProvider

# set up a loop to run 50000 times
0..49999 | Foreach-Object {

    # create a file stream handle with a name format 'filennnnn'
    $stream = New-Object System.IO.FileStream("c:\temp\file$("{0:D5}" -f $_)"), Create

    # and a stream writer handle
    $writer = New-Object System.IO.BinaryWriter($stream)

    # Fill our array from the CSRNG
    $RNGObject.GetNonZeroBytes($bytearray)

    # Append to the current file
    $writer.write($bytearray)

    # Close the stream
    $stream.close()

}
About
Products
For Teams
Search…
Join Stack Overflow to find the best answer to your technical question, help others answer theirs.

Home
PUBLIC
Questions
Tags
Users
Companies
COLLECTIVES
Explore Collectives
TEAMS
Stack Overflow for Teams – Start collaborating and sharing organizational knowledge. 
Generating Random Files in Windows
Asked 14 years, 3 months ago
Modified 5 months ago
Viewed 85k times
42

Does anyone have a way to generate files of random data in Windows? I would like to generate 50,000 small (2K) files as an example.

windows
Share
Improve this question
Follow
asked Feb 10, 2009 at 18:51
Jeff
2
Could you share with us whether you want text files or binary files? Could you also comment as to what programming languages you have access to (if any)? Do you have MS Office installed? Also, not very relevant, but what version of windows are you using? – 
user62572
 Feb 10, 2009 at 20:05
Add a comment
16 Answers
Sorted by:

Highest score (default)
34

You can run fsutil in a batch loop to create files of any size.

fsutil file createnew filename.extension 2000
Share
Improve this answer
Follow
answered Feb 10, 2009 at 19:01
Bogdan's user avatar
Bogdan
3,03511 gold badge2222 silver badges2020 bronze badges
I just found that utility. Didn't know it existed before. thebackroomtech.com/2009/01/16/… – 
beach
 Feb 10, 2009 at 19:04
41
However, it doesn't create random data. Just blank files. – 
beach
 Feb 10, 2009 at 19:07
And it seems to require admin permissions. Going with the powershell. – 
Mathias Mamsch
 Oct 25, 2017 at 7:21
Add a comment
21

One-liner in Powershell:

$out = new-object byte[] 1048576; (new-object Random).NextBytes($out); [IO.File]::WriteAllBytes('d:\file.bin', $out)
This is lightning fast, compared to @user188737 solution.

Share
Improve this answer
Follow
answered Sep 26, 2017 at 7:07
gwiazdorrr's user avatar
gwiazdorrr
6,16122 gold badges2727 silver badges3636 bronze badges
1
Every single file that this one liner creates is identical. Is there any way to make the content of each file different – 
Dhiwakar Ravikumar
 Apr 15, 2018 at 4:47
3
Are you sure this is the case? I tried it on my system, ran it 3 times, got 3 distinct files. The constructor for the Random type is by default based on the system time, so perhaps if you run this multiple times in very quick succession, you might get identical files. You could avoid this by creating a single Random object and then reusing it for each consecutive file: $rnd = New-Object Random; once at the top, and then $rnd.NextBytes instead of (New-Object Random).NextBytes when generating the file. – 
Jonathan Gilbert
 May 29, 2018 at 16:19
Add a comment
18

You can use PowerShell to generate cheap random data for your files:

[Byte[]] $out = @()
0..2047 | % {$out += Get-Random -Minimum 0 -Maximum 255}
[System.IO.File]::WriteAllBytes("myrandomfiletest", $out)
This uses an algorithm with a seed taken from the system clock, so don't use this for ANY serious cryptographic applications.

In addition, be wary of the performance degradation of Get-Random when increasing the size of the output file. More on this aspect here:

PowerShell random file generator too slow
Improve Powershell Performance to Generate a Random File
Share
Improve this answer
Follow
edited May 23, 2017 at 12:32
Community's user avatar
CommunityBot
111 silver badge
answered Sep 27, 2013 at 18:23
Gerrit's user avatar
Gerrit
85166 silver badges1111 bronze badges
Add a comment
16

I have been using Random Data File Creator and liking it, it creates binary files (i.e. not text files) filled with pseudo-random bits, it can quickly create very large files. To use it to create multiple small files you would need to script it, which would be very easy given it is command line.

Share
Improve this answer
Follow
edited Dec 25, 2015 at 11:57
mguassa's user avatar
mguassa
3,97122 gold badges1414 silver badges1919 bronze badges
answered Feb 5, 2010 at 19:20
David Waters's user avatar
David Waters
11.9k77 gold badges4141 silver badges7676 bronze badges
There are quite a few programs and cloud tools of this nature: raywoodcockslatest.wordpress.com/2021/08/21/dummy-files – 
Ray Woodcock
 May 17, 2022 at 14:08
Add a comment
8

Since you don't specify a language, I'll simply pick one at random. Here is a powershell script to do it:

$rootDir = 'C:\Temp\TestRandomFiles\'
$baseFile = $rootDir + "base.txt"
$desiredFileSize = 2*1KB
$fileCount = 50000
"start" | Out-File -Filepath $baseFile
While ($(Get-ChildItem -path $baseFile).Length -lt $desiredFileSize)
{
    $(Get-ChildItem -path $baseFile).Length | Out-File $baseFile -APPEND
}
for($i=1;$i -lt $fileCount;$i++)
{
    Copy-Item $baseFile "File$i.txt"
}
You'll have to change the variables to the parameters that you want of course.

Share
Improve this answer
Follow
answered Feb 10, 2009 at 19:47
EBGreen's user avatar
EBGreen
36.5k1212 gold badges6464 silver badges8484 bronze badges
1
oops...missed the random data requirement. Is that important? If so I can tweak it. – 
EBGreen
 Feb 10, 2009 at 19:48
1
If you are a PS whiz, I don't suppose you can do random data as I am keen to learn how this done! – 
Wil
 Jan 27, 2012 at 10:22 
I'm definitely not a whiz, but there are several ways. Basically you identify the data set that you want to randomize (say 0-9 and a-Z) then you randomly pick from that set to build the data for the file, then write it out to the file. If I have a chance later today, I'll alter the above code to use random data. – 
EBGreen
 Jan 27, 2012 at 15:12
@EBGreen thank You much! Best regards – 
Gennady G
 Nov 29, 2021 at 14:01
Add a comment
4

Instead of using Get-Random to generate the text as per user188737 & mguassa suggestions, I improved the speed by using GUIDs.

Function New-RandomFile {
    Param(
        $Path = '.', 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 
    (1..($FileSize/128)).foreach({-join ([guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-").SubString(1, 126) }) | set-content "$Path\$FileName"
}
This took 491 milliseconds to generate a 1mb file. Running:

New-RandomFile -FileSize 1mb
UPDATE:

I've updated my function to use a ScriptBlock, so you can replace the 'NewGuid()' method with anything you want.

In this scenario, I make 1kb chunks, since I know I'm never creating smaller files. This improved the speed of my function drastically!

Set-Content forces a NewLine at the end, which is why you need to remove 2 Characters each time you write to file. I've replaced it with [io.file]::WriteAllText() instead.

Function New-RandomFile_1kChunks {
    Param(
        $Path = (Resolve-Path '.').Path, 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 

    $Chunk = { [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-" }

    $Chunks = [math]::Ceiling($FileSize/1kb)

    [io.file]::WriteAllText("$Path\$FileName","$(-Join (1..($Chunks)).foreach({ $Chunk.Invoke() }))")

    Write-Warning "New-RandomFile: $Path\$FileName"

}
If you dont care that all chunks are random, you can simply Invoke() the generation of the 1kb chunk once.. this improves the speed drastically, but won't make the entire file random.

Function New-RandomFile_Fast {
    Param(
        $Path = (Resolve-Path '.').Path, 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 

    $Chunk = { [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-" }
    $Chunks = [math]::Ceiling($FileSize/1kb)
    $ChunkString = $Chunk.Invoke()

    [io.file]::WriteAllText("$Path\$FileName","$(-Join (1..($Chunks)).foreach({ $ChunkString }))")

    Write-Warning "New-RandomFile: $Path\$FileName"

}
Measure-Command all these changes to generate a 10mb file:

Executing New-RandomFile: 35.7688241 seconds.

Executing New-RandomFile_1kChunks: 25.1463777 seconds.

Executing New-RandomFile_Fast: 1.1626236 seconds.

Share
Improve this answer
Follow
edited Apr 3, 2017 at 23:04
answered Apr 1, 2017 at 2:39
Marc Kellerman's user avatar
Marc Kellerman
45622 silver badges1010 bronze badges
Add a comment
2

You'll have to create files in the normal way, and then populate them with randomized data, probably from a rand() function of some sort.

It really depends on your programming language. Windows itself certainly won't provide this capability.

There are a number of programming languages that could do this easily, however, including basic windows batch/CMD scripts. What language are you interested in using?

Share
Improve this answer
Follow
answered Feb 10, 2009 at 18:54
levand's user avatar
levand
8,39033 gold badges4040 silver badges5454 bronze badges
Add a comment
2

None of the answers here were cutting it for me, so here's a script which takes advantage of the Cryptography library to generate lots of random files.

This will generate files very quickly until your system's entropy is exhausted (on my PC this was about 4,000 files). After this it (and any other applications on your system that need cryptographic random numbers) will run very slowly. (In Linux terms, consider this script to use /dev/random instead of /dev/urandom)

$directory = (Get-Location).Path;
0..10000 | ForEach-Object {
    $size = 1023 * (Get-Random -Minimum 10 -Maximum 1536);
    $contents = [Byte[]]::new($size);

    $rng = [System.Security.Cryptography.RNGCryptoServiceProvider]::new();
    $rng.GetBytes($contents);

    $filename = "$directory\random$($_.ToString().PadLeft(5, '0')).txt"
    Write-Host $filename
    [System.IO.File]::WriteAllBytes($filename, $contents)
}
If you'd rather not deplete your system's entropy, replace the two $rng lines with these:

    $rng = [System.Random]::new();
    $rng.NextBytes($contents);
This will run much slower, but for large quantities of files (or larger files) it should be more reliable.

Share
Improve this answer
Follow
answered Apr 15, 2020 at 0:57
Joshua Walsh's user avatar
Joshua Walsh
1,88555 gold badges2525 silver badges5050 bronze badges
Add a comment
1

Yes, fsutil is great, but doesn't generate random data, just ASCII nulls.

I don't remember where I found this but searching on google these days I can still find it at: http://www.private-files.com/other/random.c.txt

I don't know how old this program is but at least as old as your question, probably somewhat older.

Anyway here's a program in C which creates files with a chi-squared test result of 0:

// ------------------------------------------------------------     
// Name: random.c  (program to create random files)
//     
// This "no-frills" program creates files with the following 
// characteristics: 
//
//    (1) Byte sequences are random (no predictability);
//    (2) Files produced are binary files; 
//    (3) File sizes are multiples of 256; 
//    (4) Files will have a chi-squared test result of 0
//        (see analyze.exe by Wenger for explanation)
//  
//              Programmer:  Scott Wenger
//                           Box 802
//                           Stevens Point, WI 54481
//                           panther@wctc.net
//
//       Note:  part of this code is from Knuth Volume II
// 
//  Enhancements and modifications of this program are left 
//  to the imagination and creativity of the programmer.
//  Check your compiler for required header files.  You may 
//  need to include the iostream header.
//
//  Random files are of potential use to cryptographers
//  for the purpose of encryption.  
//  
//  To analyze files produced by this program, see 
//  the analyze.exe program by Scott Wenger (found at
//  http://www.coredcs.com/sware.html)
// ------------------------------------------------------------


// This program works in the following way:
// The time is used to seed the random number generator.
// Using Knuth's algorithm, random numbers are generated
// in the range of 0 to 255 (corresponding to 256 ASCII chars.)
// When random numbers are generated they are marked as used and 
// are not re-used until all 256 ASCII values appear.  Characters 
// are written to disk and the process continues until the
// desired file size is reached.  Output is a random binary file
// called random.bin (placed in the root directory)
// The controlled filesize along with the placeholder feature 
// of this code forces a very high degree of randomness in 
// the output file. 

#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void init_mm();
void clear_array(); 
int  number_range(int minval, int maxval);
int  number_mm();

static int rgiState[2 + 55]; 
int place_holder[256];          // to keep track of numbers already generated

int main()
{
  mainprogram();
  return 0;
}

int mainprogram()
{
  int ch; 
  int c_used = 0;  // counter of chars in placeholder
  int done = 0; 
  int random;

  char buffer[2];

  long x;
  long byte_size = 0L;
  FILE *fp;

  clear_array();
  init_mm();  // seed random number generator

  // create a random file of length specified by user
  printf("\nrandom.exe originally by Scott Wenger");
  printf("\nThis program creates a random binary file.\n");
  printf("\nPlease specify length of random file to create (in megabytes): ");  

  scanf("%ld", &byte_size);

  while (byte_size > 1000 || byte_size <= 0 )
  {
    printf("\nWill not create files larger than a gigabyte! ");
    printf("\nPlease specify length of random file to create (in megabytes): ");
    flushall();
    scanf("%ld", &byte_size);
  }

  byte_size = byte_size * 1024 * 1024;

  if ( (fp = fopen("random.bin", "wb"))  == NULL) {
    fprintf(stderr, "\nOutput file (random.bin) could not be created.");      
    fflush(stdout);
    exit(1);
  }

  for (x = 0L; x < byte_size; x++) {

    if (c_used == 256) {
      clear_array();
      c_used = 0;
    }

    random = number_range(0, 255);    // use all ASCII values

    if ( *(place_holder + random) ) {  // already used, find another
      done = 0;
      while (!done) {
        random = number_range(0, 255);
        if ( *(place_holder + random) == 0) {
          *(place_holder + random) = 1;
          done = 1;
        }
      }         
    }
    else *(place_holder + random) = 1;  // use it and mark as used 

    c_used++;   // found next character so increment counter

    sprintf(buffer, "%c", random);  // convert ASCII value to char 
    ch = buffer[0];
    fputc(ch, fp); // write to file
  }

  fclose(fp);

  printf("\nDone. File \"random.bin\" was created (size: %ld bytes)", byte_size);
  printf("\nOutput file is in the root directory (c:\\random.bin)\n");
  return(0);
}

// ---------------------------------------------------------------------------------

void clear_array()
{
  register int x;
  for (x = 0; x < 256; x++) 
    *(place_holder + x) = 0;
}

// ---------------------------------------------------------------------------------

int number_mm()
{
    int *piState;
    int iState1;
    int iState2;
    int iRand;

    piState     = &rgiState[2];
    iState1     = piState[-2];
    iState2     = piState[-1];
    iRand       = ( piState[iState1] + piState[iState2] )
                & ( ( 1 << 30 ) - 1 );
    piState[iState1]    = iRand;

    if ( ++iState1 == 55 )  iState1 = 0;
    if ( ++iState2 == 55 )  iState2 = 0;

    piState[-2]     = iState1;
    piState[-1]     = iState2;

    return(iRand >> 6);
}

// ---------------------------------------------------------------------------------

//  Generate a random number.

int number_range( int minval, int maxval )
{
  int power, number;

  if ( ( maxval = maxval - minval + 1 ) <= 1 ) return (minval);

  for ( power = 2; power < maxval; power <<= 1 )
    ;
  while ( ( number = number_mm( ) & ( power - 1 ) ) >= maxval )
    ;
  return(minval + number);
}

// ---------------------------------------------------------------------------------

// Mitchell-Moore algorithm from Knuth Volume II. 

void init_mm( )
{
  int *piState;
  int iState;

  piState = &rgiState[2];
  piState[-2]   = 55 - 55;
  piState[-1]   = 55 - 24;
  piState[0]    = ( (int) time( NULL ) ) & ( ( 1 << 30 ) - 1 );
  piState[1]    = 1;

  for ( iState = 2; iState < 55; iState++ ) 
  {
    piState[iState] = ( piState[iState-1] + piState[iState-2] )
                      &  ( ( 1 << 30 ) - 1 );
  }
}

// -------------------- End -------------------------------------------------------
Share
Improve this answer
Follow
answered Aug 10, 2016 at 13:38
Rubenisme's user avatar
Rubenisme
78711 gold badge88 silver badges1515 bronze badges
Add a comment
1

So, i decided to add an accurate answer this time.

language is powershell. assumptions: filenames will be sequential and not random. file contents are to be cryptographically secure and unique. file location to be C:\temp\

#create a fixed size byte array for later use.  make it the required file size.
$bytearray = New-Object byte[] 2048

#create and start a stopwatch object to measure how long it all takes.
$stopwatch = [Diagnostics.Stopwatch]::StartNew()

#create a CSRNG object
$RNGObject = New-Object Security.Cryptography.RNGCryptoServiceProvider

# set up a loop to run 50000 times
0..49999 | Foreach-Object {

    # create a file stream handle with a name format 'filennnnn'
    $stream = New-Object System.IO.FileStream("c:\temp\file$("{0:D5}" -f $_)"), Create

    # and a stream writer handle
    $writer = New-Object System.IO.BinaryWriter($stream)

    # Fill our array from the CSRNG
    $RNGObject.GetNonZeroBytes($bytearray)

    # Append to the current file
    $writer.write($bytearray)

    # Close the stream
    $stream.close()

}
About
Products
For Teams
Search…
Join Stack Overflow to find the best answer to your technical question, help others answer theirs.

Home
PUBLIC
Questions
Tags
Users
Companies
COLLECTIVES
Explore Collectives
TEAMS
Stack Overflow for Teams – Start collaborating and sharing organizational knowledge. 
Generating Random Files in Windows
Asked 14 years, 3 months ago
Modified 5 months ago
Viewed 85k times
42

Does anyone have a way to generate files of random data in Windows? I would like to generate 50,000 small (2K) files as an example.

windows
Share
Improve this question
Follow
asked Feb 10, 2009 at 18:51
Jeff
2
Could you share with us whether you want text files or binary files? Could you also comment as to what programming languages you have access to (if any)? Do you have MS Office installed? Also, not very relevant, but what version of windows are you using? – 
user62572
 Feb 10, 2009 at 20:05
Add a comment
16 Answers
Sorted by:

Highest score (default)
34

You can run fsutil in a batch loop to create files of any size.

fsutil file createnew filename.extension 2000
Share
Improve this answer
Follow
answered Feb 10, 2009 at 19:01
Bogdan's user avatar
Bogdan
3,03511 gold badge2222 silver badges2020 bronze badges
I just found that utility. Didn't know it existed before. thebackroomtech.com/2009/01/16/… – 
beach
 Feb 10, 2009 at 19:04
41
However, it doesn't create random data. Just blank files. – 
beach
 Feb 10, 2009 at 19:07
And it seems to require admin permissions. Going with the powershell. – 
Mathias Mamsch
 Oct 25, 2017 at 7:21
Add a comment
21

One-liner in Powershell:

$out = new-object byte[] 1048576; (new-object Random).NextBytes($out); [IO.File]::WriteAllBytes('d:\file.bin', $out)
This is lightning fast, compared to @user188737 solution.

Share
Improve this answer
Follow
answered Sep 26, 2017 at 7:07
gwiazdorrr's user avatar
gwiazdorrr
6,16122 gold badges2727 silver badges3636 bronze badges
1
Every single file that this one liner creates is identical. Is there any way to make the content of each file different – 
Dhiwakar Ravikumar
 Apr 15, 2018 at 4:47
3
Are you sure this is the case? I tried it on my system, ran it 3 times, got 3 distinct files. The constructor for the Random type is by default based on the system time, so perhaps if you run this multiple times in very quick succession, you might get identical files. You could avoid this by creating a single Random object and then reusing it for each consecutive file: $rnd = New-Object Random; once at the top, and then $rnd.NextBytes instead of (New-Object Random).NextBytes when generating the file. – 
Jonathan Gilbert
 May 29, 2018 at 16:19
Add a comment
18

You can use PowerShell to generate cheap random data for your files:

[Byte[]] $out = @()
0..2047 | % {$out += Get-Random -Minimum 0 -Maximum 255}
[System.IO.File]::WriteAllBytes("myrandomfiletest", $out)
This uses an algorithm with a seed taken from the system clock, so don't use this for ANY serious cryptographic applications.

In addition, be wary of the performance degradation of Get-Random when increasing the size of the output file. More on this aspect here:

PowerShell random file generator too slow
Improve Powershell Performance to Generate a Random File
Share
Improve this answer
Follow
edited May 23, 2017 at 12:32
Community's user avatar
CommunityBot
111 silver badge
answered Sep 27, 2013 at 18:23
Gerrit's user avatar
Gerrit
85166 silver badges1111 bronze badges
Add a comment
16

I have been using Random Data File Creator and liking it, it creates binary files (i.e. not text files) filled with pseudo-random bits, it can quickly create very large files. To use it to create multiple small files you would need to script it, which would be very easy given it is command line.

Share
Improve this answer
Follow
edited Dec 25, 2015 at 11:57
mguassa's user avatar
mguassa
3,97122 gold badges1414 silver badges1919 bronze badges
answered Feb 5, 2010 at 19:20
David Waters's user avatar
David Waters
11.9k77 gold badges4141 silver badges7676 bronze badges
There are quite a few programs and cloud tools of this nature: raywoodcockslatest.wordpress.com/2021/08/21/dummy-files – 
Ray Woodcock
 May 17, 2022 at 14:08
Add a comment
8

Since you don't specify a language, I'll simply pick one at random. Here is a powershell script to do it:

$rootDir = 'C:\Temp\TestRandomFiles\'
$baseFile = $rootDir + "base.txt"
$desiredFileSize = 2*1KB
$fileCount = 50000
"start" | Out-File -Filepath $baseFile
While ($(Get-ChildItem -path $baseFile).Length -lt $desiredFileSize)
{
    $(Get-ChildItem -path $baseFile).Length | Out-File $baseFile -APPEND
}
for($i=1;$i -lt $fileCount;$i++)
{
    Copy-Item $baseFile "File$i.txt"
}
You'll have to change the variables to the parameters that you want of course.

Share
Improve this answer
Follow
answered Feb 10, 2009 at 19:47
EBGreen's user avatar
EBGreen
36.5k1212 gold badges6464 silver badges8484 bronze badges
1
oops...missed the random data requirement. Is that important? If so I can tweak it. – 
EBGreen
 Feb 10, 2009 at 19:48
1
If you are a PS whiz, I don't suppose you can do random data as I am keen to learn how this done! – 
Wil
 Jan 27, 2012 at 10:22 
I'm definitely not a whiz, but there are several ways. Basically you identify the data set that you want to randomize (say 0-9 and a-Z) then you randomly pick from that set to build the data for the file, then write it out to the file. If I have a chance later today, I'll alter the above code to use random data. – 
EBGreen
 Jan 27, 2012 at 15:12
@EBGreen thank You much! Best regards – 
Gennady G
 Nov 29, 2021 at 14:01
Add a comment
4

Instead of using Get-Random to generate the text as per user188737 & mguassa suggestions, I improved the speed by using GUIDs.

Function New-RandomFile {
    Param(
        $Path = '.', 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 
    (1..($FileSize/128)).foreach({-join ([guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-").SubString(1, 126) }) | set-content "$Path\$FileName"
}
This took 491 milliseconds to generate a 1mb file. Running:

New-RandomFile -FileSize 1mb
UPDATE:

I've updated my function to use a ScriptBlock, so you can replace the 'NewGuid()' method with anything you want.

In this scenario, I make 1kb chunks, since I know I'm never creating smaller files. This improved the speed of my function drastically!

Set-Content forces a NewLine at the end, which is why you need to remove 2 Characters each time you write to file. I've replaced it with [io.file]::WriteAllText() instead.

Function New-RandomFile_1kChunks {
    Param(
        $Path = (Resolve-Path '.').Path, 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 

    $Chunk = { [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-" }

    $Chunks = [math]::Ceiling($FileSize/1kb)

    [io.file]::WriteAllText("$Path\$FileName","$(-Join (1..($Chunks)).foreach({ $Chunk.Invoke() }))")

    Write-Warning "New-RandomFile: $Path\$FileName"

}
If you dont care that all chunks are random, you can simply Invoke() the generation of the 1kb chunk once.. this improves the speed drastically, but won't make the entire file random.

Function New-RandomFile_Fast {
    Param(
        $Path = (Resolve-Path '.').Path, 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 

    $Chunk = { [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-" }
    $Chunks = [math]::Ceiling($FileSize/1kb)
    $ChunkString = $Chunk.Invoke()

    [io.file]::WriteAllText("$Path\$FileName","$(-Join (1..($Chunks)).foreach({ $ChunkString }))")

    Write-Warning "New-RandomFile: $Path\$FileName"

}
Measure-Command all these changes to generate a 10mb file:

Executing New-RandomFile: 35.7688241 seconds.

Executing New-RandomFile_1kChunks: 25.1463777 seconds.

Executing New-RandomFile_Fast: 1.1626236 seconds.

Share
Improve this answer
Follow
edited Apr 3, 2017 at 23:04
answered Apr 1, 2017 at 2:39
Marc Kellerman's user avatar
Marc Kellerman
45622 silver badges1010 bronze badges
Add a comment
2

You'll have to create files in the normal way, and then populate them with randomized data, probably from a rand() function of some sort.

It really depends on your programming language. Windows itself certainly won't provide this capability.

There are a number of programming languages that could do this easily, however, including basic windows batch/CMD scripts. What language are you interested in using?

Share
Improve this answer
Follow
answered Feb 10, 2009 at 18:54
levand's user avatar
levand
8,39033 gold badges4040 silver badges5454 bronze badges
Add a comment
2

None of the answers here were cutting it for me, so here's a script which takes advantage of the Cryptography library to generate lots of random files.

This will generate files very quickly until your system's entropy is exhausted (on my PC this was about 4,000 files). After this it (and any other applications on your system that need cryptographic random numbers) will run very slowly. (In Linux terms, consider this script to use /dev/random instead of /dev/urandom)

$directory = (Get-Location).Path;
0..10000 | ForEach-Object {
    $size = 1023 * (Get-Random -Minimum 10 -Maximum 1536);
    $contents = [Byte[]]::new($size);

    $rng = [System.Security.Cryptography.RNGCryptoServiceProvider]::new();
    $rng.GetBytes($contents);

    $filename = "$directory\random$($_.ToString().PadLeft(5, '0')).txt"
    Write-Host $filename
    [System.IO.File]::WriteAllBytes($filename, $contents)
}
If you'd rather not deplete your system's entropy, replace the two $rng lines with these:

    $rng = [System.Random]::new();
    $rng.NextBytes($contents);
This will run much slower, but for large quantities of files (or larger files) it should be more reliable.

Share
Improve this answer
Follow
answered Apr 15, 2020 at 0:57
Joshua Walsh's user avatar
Joshua Walsh
1,88555 gold badges2525 silver badges5050 bronze badges
Add a comment
1

Yes, fsutil is great, but doesn't generate random data, just ASCII nulls.

I don't remember where I found this but searching on google these days I can still find it at: http://www.private-files.com/other/random.c.txt

I don't know how old this program is but at least as old as your question, probably somewhat older.

Anyway here's a program in C which creates files with a chi-squared test result of 0:

// ------------------------------------------------------------     
// Name: random.c  (program to create random files)
//     
// This "no-frills" program creates files with the following 
// characteristics: 
//
//    (1) Byte sequences are random (no predictability);
//    (2) Files produced are binary files; 
//    (3) File sizes are multiples of 256; 
//    (4) Files will have a chi-squared test result of 0
//        (see analyze.exe by Wenger for explanation)
//  
//              Programmer:  Scott Wenger
//                           Box 802
//                           Stevens Point, WI 54481
//                           panther@wctc.net
//
//       Note:  part of this code is from Knuth Volume II
// 
//  Enhancements and modifications of this program are left 
//  to the imagination and creativity of the programmer.
//  Check your compiler for required header files.  You may 
//  need to include the iostream header.
//
//  Random files are of potential use to cryptographers
//  for the purpose of encryption.  
//  
//  To analyze files produced by this program, see 
//  the analyze.exe program by Scott Wenger (found at
//  http://www.coredcs.com/sware.html)
// ------------------------------------------------------------


// This program works in the following way:
// The time is used to seed the random number generator.
// Using Knuth's algorithm, random numbers are generated
// in the range of 0 to 255 (corresponding to 256 ASCII chars.)
// When random numbers are generated they are marked as used and 
// are not re-used until all 256 ASCII values appear.  Characters 
// are written to disk and the process continues until the
// desired file size is reached.  Output is a random binary file
// called random.bin (placed in the root directory)
// The controlled filesize along with the placeholder feature 
// of this code forces a very high degree of randomness in 
// the output file. 

#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void init_mm();
void clear_array(); 
int  number_range(int minval, int maxval);
int  number_mm();

static int rgiState[2 + 55]; 
int place_holder[256];          // to keep track of numbers already generated

int main()
{
  mainprogram();
  return 0;
}

int mainprogram()
{
  int ch; 
  int c_used = 0;  // counter of chars in placeholder
  int done = 0; 
  int random;

  char buffer[2];

  long x;
  long byte_size = 0L;
  FILE *fp;

  clear_array();
  init_mm();  // seed random number generator

  // create a random file of length specified by user
  printf("\nrandom.exe originally by Scott Wenger");
  printf("\nThis program creates a random binary file.\n");
  printf("\nPlease specify length of random file to create (in megabytes): ");  

  scanf("%ld", &byte_size);

  while (byte_size > 1000 || byte_size <= 0 )
  {
    printf("\nWill not create files larger than a gigabyte! ");
    printf("\nPlease specify length of random file to create (in megabytes): ");
    flushall();
    scanf("%ld", &byte_size);
  }

  byte_size = byte_size * 1024 * 1024;

  if ( (fp = fopen("random.bin", "wb"))  == NULL) {
    fprintf(stderr, "\nOutput file (random.bin) could not be created.");      
    fflush(stdout);
    exit(1);
  }

  for (x = 0L; x < byte_size; x++) {

    if (c_used == 256) {
      clear_array();
      c_used = 0;
    }

    random = number_range(0, 255);    // use all ASCII values

    if ( *(place_holder + random) ) {  // already used, find another
      done = 0;
      while (!done) {
        random = number_range(0, 255);
        if ( *(place_holder + random) == 0) {
          *(place_holder + random) = 1;
          done = 1;
        }
      }         
    }
    else *(place_holder + random) = 1;  // use it and mark as used 

    c_used++;   // found next character so increment counter

    sprintf(buffer, "%c", random);  // convert ASCII value to char 
    ch = buffer[0];
    fputc(ch, fp); // write to file
  }

  fclose(fp);

  printf("\nDone. File \"random.bin\" was created (size: %ld bytes)", byte_size);
  printf("\nOutput file is in the root directory (c:\\random.bin)\n");
  return(0);
}

// ---------------------------------------------------------------------------------

void clear_array()
{
  register int x;
  for (x = 0; x < 256; x++) 
    *(place_holder + x) = 0;
}

// ---------------------------------------------------------------------------------

int number_mm()
{
    int *piState;
    int iState1;
    int iState2;
    int iRand;

    piState     = &rgiState[2];
    iState1     = piState[-2];
    iState2     = piState[-1];
    iRand       = ( piState[iState1] + piState[iState2] )
                & ( ( 1 << 30 ) - 1 );
    piState[iState1]    = iRand;

    if ( ++iState1 == 55 )  iState1 = 0;
    if ( ++iState2 == 55 )  iState2 = 0;

    piState[-2]     = iState1;
    piState[-1]     = iState2;

    return(iRand >> 6);
}

// ---------------------------------------------------------------------------------

//  Generate a random number.

int number_range( int minval, int maxval )
{
  int power, number;

  if ( ( maxval = maxval - minval + 1 ) <= 1 ) return (minval);

  for ( power = 2; power < maxval; power <<= 1 )
    ;
  while ( ( number = number_mm( ) & ( power - 1 ) ) >= maxval )
    ;
  return(minval + number);
}

// ---------------------------------------------------------------------------------

// Mitchell-Moore algorithm from Knuth Volume II. 

void init_mm( )
{
  int *piState;
  int iState;

  piState = &rgiState[2];
  piState[-2]   = 55 - 55;
  piState[-1]   = 55 - 24;
  piState[0]    = ( (int) time( NULL ) ) & ( ( 1 << 30 ) - 1 );
  piState[1]    = 1;

  for ( iState = 2; iState < 55; iState++ ) 
  {
    piState[iState] = ( piState[iState-1] + piState[iState-2] )
                      &  ( ( 1 << 30 ) - 1 );
  }
}

// -------------------- End -------------------------------------------------------
Share
Improve this answer
Follow
answered Aug 10, 2016 at 13:38
Rubenisme's user avatar
Rubenisme
78711 gold badge88 silver badges1515 bronze badges
Add a comment
1

So, i decided to add an accurate answer this time.

language is powershell. assumptions: filenames will be sequential and not random. file contents are to be cryptographically secure and unique. file location to be C:\temp\

#create a fixed size byte array for later use.  make it the required file size.
$bytearray = New-Object byte[] 2048

#create and start a stopwatch object to measure how long it all takes.
$stopwatch = [Diagnostics.Stopwatch]::StartNew()

#create a CSRNG object
$RNGObject = New-Object Security.Cryptography.RNGCryptoServiceProvider

# set up a loop to run 50000 times
0..49999 | Foreach-Object {

    # create a file stream handle with a name format 'filennnnn'
    $stream = New-Object System.IO.FileStream("c:\temp\file$("{0:D5}" -f $_)"), Create

    # and a stream writer handle
    $writer = New-Object System.IO.BinaryWriter($stream)

    # Fill our array from the CSRNG
    $RNGObject.GetNonZeroBytes($bytearray)

    # Append to the current file
    $writer.write($bytearray)

    # Close the stream
    $stream.close()

}
About
Products
For Teams
Search…
Join Stack Overflow to find the best answer to your technical question, help others answer theirs.

Home
PUBLIC
Questions
Tags
Users
Companies
COLLECTIVES
Explore Collectives
TEAMS
Stack Overflow for Teams – Start collaborating and sharing organizational knowledge. 
Generating Random Files in Windows
Asked 14 years, 3 months ago
Modified 5 months ago
Viewed 85k times
42

Does anyone have a way to generate files of random data in Windows? I would like to generate 50,000 small (2K) files as an example.

windows
Share
Improve this question
Follow
asked Feb 10, 2009 at 18:51
Jeff
2
Could you share with us whether you want text files or binary files? Could you also comment as to what programming languages you have access to (if any)? Do you have MS Office installed? Also, not very relevant, but what version of windows are you using? – 
user62572
 Feb 10, 2009 at 20:05
Add a comment
16 Answers
Sorted by:

Highest score (default)
34

You can run fsutil in a batch loop to create files of any size.

fsutil file createnew filename.extension 2000
Share
Improve this answer
Follow
answered Feb 10, 2009 at 19:01
Bogdan's user avatar
Bogdan
3,03511 gold badge2222 silver badges2020 bronze badges
I just found that utility. Didn't know it existed before. thebackroomtech.com/2009/01/16/… – 
beach
 Feb 10, 2009 at 19:04
41
However, it doesn't create random data. Just blank files. – 
beach
 Feb 10, 2009 at 19:07
And it seems to require admin permissions. Going with the powershell. – 
Mathias Mamsch
 Oct 25, 2017 at 7:21
Add a comment
21

One-liner in Powershell:

$out = new-object byte[] 1048576; (new-object Random).NextBytes($out); [IO.File]::WriteAllBytes('d:\file.bin', $out)
This is lightning fast, compared to @user188737 solution.

Share
Improve this answer
Follow
answered Sep 26, 2017 at 7:07
gwiazdorrr's user avatar
gwiazdorrr
6,16122 gold badges2727 silver badges3636 bronze badges
1
Every single file that this one liner creates is identical. Is there any way to make the content of each file different – 
Dhiwakar Ravikumar
 Apr 15, 2018 at 4:47
3
Are you sure this is the case? I tried it on my system, ran it 3 times, got 3 distinct files. The constructor for the Random type is by default based on the system time, so perhaps if you run this multiple times in very quick succession, you might get identical files. You could avoid this by creating a single Random object and then reusing it for each consecutive file: $rnd = New-Object Random; once at the top, and then $rnd.NextBytes instead of (New-Object Random).NextBytes when generating the file. – 
Jonathan Gilbert
 May 29, 2018 at 16:19
Add a comment
18

You can use PowerShell to generate cheap random data for your files:

[Byte[]] $out = @()
0..2047 | % {$out += Get-Random -Minimum 0 -Maximum 255}
[System.IO.File]::WriteAllBytes("myrandomfiletest", $out)
This uses an algorithm with a seed taken from the system clock, so don't use this for ANY serious cryptographic applications.

In addition, be wary of the performance degradation of Get-Random when increasing the size of the output file. More on this aspect here:

PowerShell random file generator too slow
Improve Powershell Performance to Generate a Random File
Share
Improve this answer
Follow
edited May 23, 2017 at 12:32
Community's user avatar
CommunityBot
111 silver badge
answered Sep 27, 2013 at 18:23
Gerrit's user avatar
Gerrit
85166 silver badges1111 bronze badges
Add a comment
16

I have been using Random Data File Creator and liking it, it creates binary files (i.e. not text files) filled with pseudo-random bits, it can quickly create very large files. To use it to create multiple small files you would need to script it, which would be very easy given it is command line.

Share
Improve this answer
Follow
edited Dec 25, 2015 at 11:57
mguassa's user avatar
mguassa
3,97122 gold badges1414 silver badges1919 bronze badges
answered Feb 5, 2010 at 19:20
David Waters's user avatar
David Waters
11.9k77 gold badges4141 silver badges7676 bronze badges
There are quite a few programs and cloud tools of this nature: raywoodcockslatest.wordpress.com/2021/08/21/dummy-files – 
Ray Woodcock
 May 17, 2022 at 14:08
Add a comment
8

Since you don't specify a language, I'll simply pick one at random. Here is a powershell script to do it:

$rootDir = 'C:\Temp\TestRandomFiles\'
$baseFile = $rootDir + "base.txt"
$desiredFileSize = 2*1KB
$fileCount = 50000
"start" | Out-File -Filepath $baseFile
While ($(Get-ChildItem -path $baseFile).Length -lt $desiredFileSize)
{
    $(Get-ChildItem -path $baseFile).Length | Out-File $baseFile -APPEND
}
for($i=1;$i -lt $fileCount;$i++)
{
    Copy-Item $baseFile "File$i.txt"
}
You'll have to change the variables to the parameters that you want of course.

Share
Improve this answer
Follow
answered Feb 10, 2009 at 19:47
EBGreen's user avatar
EBGreen
36.5k1212 gold badges6464 silver badges8484 bronze badges
1
oops...missed the random data requirement. Is that important? If so I can tweak it. – 
EBGreen
 Feb 10, 2009 at 19:48
1
If you are a PS whiz, I don't suppose you can do random data as I am keen to learn how this done! – 
Wil
 Jan 27, 2012 at 10:22 
I'm definitely not a whiz, but there are several ways. Basically you identify the data set that you want to randomize (say 0-9 and a-Z) then you randomly pick from that set to build the data for the file, then write it out to the file. If I have a chance later today, I'll alter the above code to use random data. – 
EBGreen
 Jan 27, 2012 at 15:12
@EBGreen thank You much! Best regards – 
Gennady G
 Nov 29, 2021 at 14:01
Add a comment
4

Instead of using Get-Random to generate the text as per user188737 & mguassa suggestions, I improved the speed by using GUIDs.

Function New-RandomFile {
    Param(
        $Path = '.', 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 
    (1..($FileSize/128)).foreach({-join ([guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-").SubString(1, 126) }) | set-content "$Path\$FileName"
}
This took 491 milliseconds to generate a 1mb file. Running:

New-RandomFile -FileSize 1mb
UPDATE:

I've updated my function to use a ScriptBlock, so you can replace the 'NewGuid()' method with anything you want.

In this scenario, I make 1kb chunks, since I know I'm never creating smaller files. This improved the speed of my function drastically!

Set-Content forces a NewLine at the end, which is why you need to remove 2 Characters each time you write to file. I've replaced it with [io.file]::WriteAllText() instead.

Function New-RandomFile_1kChunks {
    Param(
        $Path = (Resolve-Path '.').Path, 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 

    $Chunk = { [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-" }

    $Chunks = [math]::Ceiling($FileSize/1kb)

    [io.file]::WriteAllText("$Path\$FileName","$(-Join (1..($Chunks)).foreach({ $Chunk.Invoke() }))")

    Write-Warning "New-RandomFile: $Path\$FileName"

}
If you dont care that all chunks are random, you can simply Invoke() the generation of the 1kb chunk once.. this improves the speed drastically, but won't make the entire file random.

Function New-RandomFile_Fast {
    Param(
        $Path = (Resolve-Path '.').Path, 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 

    $Chunk = { [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-" }
    $Chunks = [math]::Ceiling($FileSize/1kb)
    $ChunkString = $Chunk.Invoke()

    [io.file]::WriteAllText("$Path\$FileName","$(-Join (1..($Chunks)).foreach({ $ChunkString }))")

    Write-Warning "New-RandomFile: $Path\$FileName"

}
Measure-Command all these changes to generate a 10mb file:

Executing New-RandomFile: 35.7688241 seconds.

Executing New-RandomFile_1kChunks: 25.1463777 seconds.

Executing New-RandomFile_Fast: 1.1626236 seconds.

Share
Improve this answer
Follow
edited Apr 3, 2017 at 23:04
answered Apr 1, 2017 at 2:39
Marc Kellerman's user avatar
Marc Kellerman
45622 silver badges1010 bronze badges
Add a comment
2

You'll have to create files in the normal way, and then populate them with randomized data, probably from a rand() function of some sort.

It really depends on your programming language. Windows itself certainly won't provide this capability.

There are a number of programming languages that could do this easily, however, including basic windows batch/CMD scripts. What language are you interested in using?

Share
Improve this answer
Follow
answered Feb 10, 2009 at 18:54
levand's user avatar
levand
8,39033 gold badges4040 silver badges5454 bronze badges
Add a comment
2

None of the answers here were cutting it for me, so here's a script which takes advantage of the Cryptography library to generate lots of random files.

This will generate files very quickly until your system's entropy is exhausted (on my PC this was about 4,000 files). After this it (and any other applications on your system that need cryptographic random numbers) will run very slowly. (In Linux terms, consider this script to use /dev/random instead of /dev/urandom)

$directory = (Get-Location).Path;
0..10000 | ForEach-Object {
    $size = 1023 * (Get-Random -Minimum 10 -Maximum 1536);
    $contents = [Byte[]]::new($size);

    $rng = [System.Security.Cryptography.RNGCryptoServiceProvider]::new();
    $rng.GetBytes($contents);

    $filename = "$directory\random$($_.ToString().PadLeft(5, '0')).txt"
    Write-Host $filename
    [System.IO.File]::WriteAllBytes($filename, $contents)
}
If you'd rather not deplete your system's entropy, replace the two $rng lines with these:

    $rng = [System.Random]::new();
    $rng.NextBytes($contents);
This will run much slower, but for large quantities of files (or larger files) it should be more reliable.

Share
Improve this answer
Follow
answered Apr 15, 2020 at 0:57
Joshua Walsh's user avatar
Joshua Walsh
1,88555 gold badges2525 silver badges5050 bronze badges
Add a comment
1

Yes, fsutil is great, but doesn't generate random data, just ASCII nulls.

I don't remember where I found this but searching on google these days I can still find it at: http://www.private-files.com/other/random.c.txt

I don't know how old this program is but at least as old as your question, probably somewhat older.

Anyway here's a program in C which creates files with a chi-squared test result of 0:

// ------------------------------------------------------------     
// Name: random.c  (program to create random files)
//     
// This "no-frills" program creates files with the following 
// characteristics: 
//
//    (1) Byte sequences are random (no predictability);
//    (2) Files produced are binary files; 
//    (3) File sizes are multiples of 256; 
//    (4) Files will have a chi-squared test result of 0
//        (see analyze.exe by Wenger for explanation)
//  
//              Programmer:  Scott Wenger
//                           Box 802
//                           Stevens Point, WI 54481
//                           panther@wctc.net
//
//       Note:  part of this code is from Knuth Volume II
// 
//  Enhancements and modifications of this program are left 
//  to the imagination and creativity of the programmer.
//  Check your compiler for required header files.  You may 
//  need to include the iostream header.
//
//  Random files are of potential use to cryptographers
//  for the purpose of encryption.  
//  
//  To analyze files produced by this program, see 
//  the analyze.exe program by Scott Wenger (found at
//  http://www.coredcs.com/sware.html)
// ------------------------------------------------------------


// This program works in the following way:
// The time is used to seed the random number generator.
// Using Knuth's algorithm, random numbers are generated
// in the range of 0 to 255 (corresponding to 256 ASCII chars.)
// When random numbers are generated they are marked as used and 
// are not re-used until all 256 ASCII values appear.  Characters 
// are written to disk and the process continues until the
// desired file size is reached.  Output is a random binary file
// called random.bin (placed in the root directory)
// The controlled filesize along with the placeholder feature 
// of this code forces a very high degree of randomness in 
// the output file. 

#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void init_mm();
void clear_array(); 
int  number_range(int minval, int maxval);
int  number_mm();

static int rgiState[2 + 55]; 
int place_holder[256];          // to keep track of numbers already generated

int main()
{
  mainprogram();
  return 0;
}

int mainprogram()
{
  int ch; 
  int c_used = 0;  // counter of chars in placeholder
  int done = 0; 
  int random;

  char buffer[2];

  long x;
  long byte_size = 0L;
  FILE *fp;

  clear_array();
  init_mm();  // seed random number generator

  // create a random file of length specified by user
  printf("\nrandom.exe originally by Scott Wenger");
  printf("\nThis program creates a random binary file.\n");
  printf("\nPlease specify length of random file to create (in megabytes): ");  

  scanf("%ld", &byte_size);

  while (byte_size > 1000 || byte_size <= 0 )
  {
    printf("\nWill not create files larger than a gigabyte! ");
    printf("\nPlease specify length of random file to create (in megabytes): ");
    flushall();
    scanf("%ld", &byte_size);
  }

  byte_size = byte_size * 1024 * 1024;

  if ( (fp = fopen("random.bin", "wb"))  == NULL) {
    fprintf(stderr, "\nOutput file (random.bin) could not be created.");      
    fflush(stdout);
    exit(1);
  }

  for (x = 0L; x < byte_size; x++) {

    if (c_used == 256) {
      clear_array();
      c_used = 0;
    }

    random = number_range(0, 255);    // use all ASCII values

    if ( *(place_holder + random) ) {  // already used, find another
      done = 0;
      while (!done) {
        random = number_range(0, 255);
        if ( *(place_holder + random) == 0) {
          *(place_holder + random) = 1;
          done = 1;
        }
      }         
    }
    else *(place_holder + random) = 1;  // use it and mark as used 

    c_used++;   // found next character so increment counter

    sprintf(buffer, "%c", random);  // convert ASCII value to char 
    ch = buffer[0];
    fputc(ch, fp); // write to file
  }

  fclose(fp);

  printf("\nDone. File \"random.bin\" was created (size: %ld bytes)", byte_size);
  printf("\nOutput file is in the root directory (c:\\random.bin)\n");
  return(0);
}

// ---------------------------------------------------------------------------------

void clear_array()
{
  register int x;
  for (x = 0; x < 256; x++) 
    *(place_holder + x) = 0;
}

// ---------------------------------------------------------------------------------

int number_mm()
{
    int *piState;
    int iState1;
    int iState2;
    int iRand;

    piState     = &rgiState[2];
    iState1     = piState[-2];
    iState2     = piState[-1];
    iRand       = ( piState[iState1] + piState[iState2] )
                & ( ( 1 << 30 ) - 1 );
    piState[iState1]    = iRand;

    if ( ++iState1 == 55 )  iState1 = 0;
    if ( ++iState2 == 55 )  iState2 = 0;

    piState[-2]     = iState1;
    piState[-1]     = iState2;

    return(iRand >> 6);
}

// ---------------------------------------------------------------------------------

//  Generate a random number.

int number_range( int minval, int maxval )
{
  int power, number;

  if ( ( maxval = maxval - minval + 1 ) <= 1 ) return (minval);

  for ( power = 2; power < maxval; power <<= 1 )
    ;
  while ( ( number = number_mm( ) & ( power - 1 ) ) >= maxval )
    ;
  return(minval + number);
}

// ---------------------------------------------------------------------------------

// Mitchell-Moore algorithm from Knuth Volume II. 

void init_mm( )
{
  int *piState;
  int iState;

  piState = &rgiState[2];
  piState[-2]   = 55 - 55;
  piState[-1]   = 55 - 24;
  piState[0]    = ( (int) time( NULL ) ) & ( ( 1 << 30 ) - 1 );
  piState[1]    = 1;

  for ( iState = 2; iState < 55; iState++ ) 
  {
    piState[iState] = ( piState[iState-1] + piState[iState-2] )
                      &  ( ( 1 << 30 ) - 1 );
  }
}

// -------------------- End -------------------------------------------------------
Share
Improve this answer
Follow
answered Aug 10, 2016 at 13:38
Rubenisme's user avatar
Rubenisme
78711 gold badge88 silver badges1515 bronze badges
Add a comment
1

So, i decided to add an accurate answer this time.

language is powershell. assumptions: filenames will be sequential and not random. file contents are to be cryptographically secure and unique. file location to be C:\temp\

#create a fixed size byte array for later use.  make it the required file size.
$bytearray = New-Object byte[] 2048

#create and start a stopwatch object to measure how long it all takes.
$stopwatch = [Diagnostics.Stopwatch]::StartNew()

#create a CSRNG object
$RNGObject = New-Object Security.Cryptography.RNGCryptoServiceProvider

# set up a loop to run 50000 times
0..49999 | Foreach-Object {

    # create a file stream handle with a name format 'filennnnn'
    $stream = New-Object System.IO.FileStream("c:\temp\file$("{0:D5}" -f $_)"), Create

    # and a stream writer handle
    $writer = New-Object System.IO.BinaryWriter($stream)

    # Fill our array from the CSRNG
    $RNGObject.GetNonZeroBytes($bytearray)

    # Append to the current file
    $writer.write($bytearray)

    # Close the stream
    $stream.close()

}
About
Products
For Teams
Search…
Join Stack Overflow to find the best answer to your technical question, help others answer theirs.

Home
PUBLIC
Questions
Tags
Users
Companies
COLLECTIVES
Explore Collectives
TEAMS
Stack Overflow for Teams – Start collaborating and sharing organizational knowledge. 
Generating Random Files in Windows
Asked 14 years, 3 months ago
Modified 5 months ago
Viewed 85k times
42

Does anyone have a way to generate files of random data in Windows? I would like to generate 50,000 small (2K) files as an example.

windows
Share
Improve this question
Follow
asked Feb 10, 2009 at 18:51
Jeff
2
Could you share with us whether you want text files or binary files? Could you also comment as to what programming languages you have access to (if any)? Do you have MS Office installed? Also, not very relevant, but what version of windows are you using? – 
user62572
 Feb 10, 2009 at 20:05
Add a comment
16 Answers
Sorted by:

Highest score (default)
34

You can run fsutil in a batch loop to create files of any size.

fsutil file createnew filename.extension 2000
Share
Improve this answer
Follow
answered Feb 10, 2009 at 19:01
Bogdan's user avatar
Bogdan
3,03511 gold badge2222 silver badges2020 bronze badges
I just found that utility. Didn't know it existed before. thebackroomtech.com/2009/01/16/… – 
beach
 Feb 10, 2009 at 19:04
41
However, it doesn't create random data. Just blank files. – 
beach
 Feb 10, 2009 at 19:07
And it seems to require admin permissions. Going with the powershell. – 
Mathias Mamsch
 Oct 25, 2017 at 7:21
Add a comment
21

One-liner in Powershell:

$out = new-object byte[] 1048576; (new-object Random).NextBytes($out); [IO.File]::WriteAllBytes('d:\file.bin', $out)
This is lightning fast, compared to @user188737 solution.

Share
Improve this answer
Follow
answered Sep 26, 2017 at 7:07
gwiazdorrr's user avatar
gwiazdorrr
6,16122 gold badges2727 silver badges3636 bronze badges
1
Every single file that this one liner creates is identical. Is there any way to make the content of each file different – 
Dhiwakar Ravikumar
 Apr 15, 2018 at 4:47
3
Are you sure this is the case? I tried it on my system, ran it 3 times, got 3 distinct files. The constructor for the Random type is by default based on the system time, so perhaps if you run this multiple times in very quick succession, you might get identical files. You could avoid this by creating a single Random object and then reusing it for each consecutive file: $rnd = New-Object Random; once at the top, and then $rnd.NextBytes instead of (New-Object Random).NextBytes when generating the file. – 
Jonathan Gilbert
 May 29, 2018 at 16:19
Add a comment
18

You can use PowerShell to generate cheap random data for your files:

[Byte[]] $out = @()
0..2047 | % {$out += Get-Random -Minimum 0 -Maximum 255}
[System.IO.File]::WriteAllBytes("myrandomfiletest", $out)
This uses an algorithm with a seed taken from the system clock, so don't use this for ANY serious cryptographic applications.

In addition, be wary of the performance degradation of Get-Random when increasing the size of the output file. More on this aspect here:

PowerShell random file generator too slow
Improve Powershell Performance to Generate a Random File
Share
Improve this answer
Follow
edited May 23, 2017 at 12:32
Community's user avatar
CommunityBot
111 silver badge
answered Sep 27, 2013 at 18:23
Gerrit's user avatar
Gerrit
85166 silver badges1111 bronze badges
Add a comment
16

I have been using Random Data File Creator and liking it, it creates binary files (i.e. not text files) filled with pseudo-random bits, it can quickly create very large files. To use it to create multiple small files you would need to script it, which would be very easy given it is command line.

Share
Improve this answer
Follow
edited Dec 25, 2015 at 11:57
mguassa's user avatar
mguassa
3,97122 gold badges1414 silver badges1919 bronze badges
answered Feb 5, 2010 at 19:20
David Waters's user avatar
David Waters
11.9k77 gold badges4141 silver badges7676 bronze badges
There are quite a few programs and cloud tools of this nature: raywoodcockslatest.wordpress.com/2021/08/21/dummy-files – 
Ray Woodcock
 May 17, 2022 at 14:08
Add a comment
8

Since you don't specify a language, I'll simply pick one at random. Here is a powershell script to do it:

$rootDir = 'C:\Temp\TestRandomFiles\'
$baseFile = $rootDir + "base.txt"
$desiredFileSize = 2*1KB
$fileCount = 50000
"start" | Out-File -Filepath $baseFile
While ($(Get-ChildItem -path $baseFile).Length -lt $desiredFileSize)
{
    $(Get-ChildItem -path $baseFile).Length | Out-File $baseFile -APPEND
}
for($i=1;$i -lt $fileCount;$i++)
{
    Copy-Item $baseFile "File$i.txt"
}
You'll have to change the variables to the parameters that you want of course.

Share
Improve this answer
Follow
answered Feb 10, 2009 at 19:47
EBGreen's user avatar
EBGreen
36.5k1212 gold badges6464 silver badges8484 bronze badges
1
oops...missed the random data requirement. Is that important? If so I can tweak it. – 
EBGreen
 Feb 10, 2009 at 19:48
1
If you are a PS whiz, I don't suppose you can do random data as I am keen to learn how this done! – 
Wil
 Jan 27, 2012 at 10:22 
I'm definitely not a whiz, but there are several ways. Basically you identify the data set that you want to randomize (say 0-9 and a-Z) then you randomly pick from that set to build the data for the file, then write it out to the file. If I have a chance later today, I'll alter the above code to use random data. – 
EBGreen
 Jan 27, 2012 at 15:12
@EBGreen thank You much! Best regards – 
Gennady G
 Nov 29, 2021 at 14:01
Add a comment
4

Instead of using Get-Random to generate the text as per user188737 & mguassa suggestions, I improved the speed by using GUIDs.

Function New-RandomFile {
    Param(
        $Path = '.', 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 
    (1..($FileSize/128)).foreach({-join ([guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-").SubString(1, 126) }) | set-content "$Path\$FileName"
}
This took 491 milliseconds to generate a 1mb file. Running:

New-RandomFile -FileSize 1mb
UPDATE:

I've updated my function to use a ScriptBlock, so you can replace the 'NewGuid()' method with anything you want.

In this scenario, I make 1kb chunks, since I know I'm never creating smaller files. This improved the speed of my function drastically!

Set-Content forces a NewLine at the end, which is why you need to remove 2 Characters each time you write to file. I've replaced it with [io.file]::WriteAllText() instead.

Function New-RandomFile_1kChunks {
    Param(
        $Path = (Resolve-Path '.').Path, 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 

    $Chunk = { [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-" }

    $Chunks = [math]::Ceiling($FileSize/1kb)

    [io.file]::WriteAllText("$Path\$FileName","$(-Join (1..($Chunks)).foreach({ $Chunk.Invoke() }))")

    Write-Warning "New-RandomFile: $Path\$FileName"

}
If you dont care that all chunks are random, you can simply Invoke() the generation of the 1kb chunk once.. this improves the speed drastically, but won't make the entire file random.

Function New-RandomFile_Fast {
    Param(
        $Path = (Resolve-Path '.').Path, 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 

    $Chunk = { [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-" }
    $Chunks = [math]::Ceiling($FileSize/1kb)
    $ChunkString = $Chunk.Invoke()

    [io.file]::WriteAllText("$Path\$FileName","$(-Join (1..($Chunks)).foreach({ $ChunkString }))")

    Write-Warning "New-RandomFile: $Path\$FileName"

}
Measure-Command all these changes to generate a 10mb file:

Executing New-RandomFile: 35.7688241 seconds.

Executing New-RandomFile_1kChunks: 25.1463777 seconds.

Executing New-RandomFile_Fast: 1.1626236 seconds.

Share
Improve this answer
Follow
edited Apr 3, 2017 at 23:04
answered Apr 1, 2017 at 2:39
Marc Kellerman's user avatar
Marc Kellerman
45622 silver badges1010 bronze badges
Add a comment
2

You'll have to create files in the normal way, and then populate them with randomized data, probably from a rand() function of some sort.

It really depends on your programming language. Windows itself certainly won't provide this capability.

There are a number of programming languages that could do this easily, however, including basic windows batch/CMD scripts. What language are you interested in using?

Share
Improve this answer
Follow
answered Feb 10, 2009 at 18:54
levand's user avatar
levand
8,39033 gold badges4040 silver badges5454 bronze badges
Add a comment
2

None of the answers here were cutting it for me, so here's a script which takes advantage of the Cryptography library to generate lots of random files.

This will generate files very quickly until your system's entropy is exhausted (on my PC this was about 4,000 files). After this it (and any other applications on your system that need cryptographic random numbers) will run very slowly. (In Linux terms, consider this script to use /dev/random instead of /dev/urandom)

$directory = (Get-Location).Path;
0..10000 | ForEach-Object {
    $size = 1023 * (Get-Random -Minimum 10 -Maximum 1536);
    $contents = [Byte[]]::new($size);

    $rng = [System.Security.Cryptography.RNGCryptoServiceProvider]::new();
    $rng.GetBytes($contents);

    $filename = "$directory\random$($_.ToString().PadLeft(5, '0')).txt"
    Write-Host $filename
    [System.IO.File]::WriteAllBytes($filename, $contents)
}
If you'd rather not deplete your system's entropy, replace the two $rng lines with these:

    $rng = [System.Random]::new();
    $rng.NextBytes($contents);
This will run much slower, but for large quantities of files (or larger files) it should be more reliable.

Share
Improve this answer
Follow
answered Apr 15, 2020 at 0:57
Joshua Walsh's user avatar
Joshua Walsh
1,88555 gold badges2525 silver badges5050 bronze badges
Add a comment
1

Yes, fsutil is great, but doesn't generate random data, just ASCII nulls.

I don't remember where I found this but searching on google these days I can still find it at: http://www.private-files.com/other/random.c.txt

I don't know how old this program is but at least as old as your question, probably somewhat older.

Anyway here's a program in C which creates files with a chi-squared test result of 0:

// ------------------------------------------------------------     
// Name: random.c  (program to create random files)
//     
// This "no-frills" program creates files with the following 
// characteristics: 
//
//    (1) Byte sequences are random (no predictability);
//    (2) Files produced are binary files; 
//    (3) File sizes are multiples of 256; 
//    (4) Files will have a chi-squared test result of 0
//        (see analyze.exe by Wenger for explanation)
//  
//              Programmer:  Scott Wenger
//                           Box 802
//                           Stevens Point, WI 54481
//                           panther@wctc.net
//
//       Note:  part of this code is from Knuth Volume II
// 
//  Enhancements and modifications of this program are left 
//  to the imagination and creativity of the programmer.
//  Check your compiler for required header files.  You may 
//  need to include the iostream header.
//
//  Random files are of potential use to cryptographers
//  for the purpose of encryption.  
//  
//  To analyze files produced by this program, see 
//  the analyze.exe program by Scott Wenger (found at
//  http://www.coredcs.com/sware.html)
// ------------------------------------------------------------


// This program works in the following way:
// The time is used to seed the random number generator.
// Using Knuth's algorithm, random numbers are generated
// in the range of 0 to 255 (corresponding to 256 ASCII chars.)
// When random numbers are generated they are marked as used and 
// are not re-used until all 256 ASCII values appear.  Characters 
// are written to disk and the process continues until the
// desired file size is reached.  Output is a random binary file
// called random.bin (placed in the root directory)
// The controlled filesize along with the placeholder feature 
// of this code forces a very high degree of randomness in 
// the output file. 

#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void init_mm();
void clear_array(); 
int  number_range(int minval, int maxval);
int  number_mm();

static int rgiState[2 + 55]; 
int place_holder[256];          // to keep track of numbers already generated

int main()
{
  mainprogram();
  return 0;
}

int mainprogram()
{
  int ch; 
  int c_used = 0;  // counter of chars in placeholder
  int done = 0; 
  int random;

  char buffer[2];

  long x;
  long byte_size = 0L;
  FILE *fp;

  clear_array();
  init_mm();  // seed random number generator

  // create a random file of length specified by user
  printf("\nrandom.exe originally by Scott Wenger");
  printf("\nThis program creates a random binary file.\n");
  printf("\nPlease specify length of random file to create (in megabytes): ");  

  scanf("%ld", &byte_size);

  while (byte_size > 1000 || byte_size <= 0 )
  {
    printf("\nWill not create files larger than a gigabyte! ");
    printf("\nPlease specify length of random file to create (in megabytes): ");
    flushall();
    scanf("%ld", &byte_size);
  }

  byte_size = byte_size * 1024 * 1024;

  if ( (fp = fopen("random.bin", "wb"))  == NULL) {
    fprintf(stderr, "\nOutput file (random.bin) could not be created.");      
    fflush(stdout);
    exit(1);
  }

  for (x = 0L; x < byte_size; x++) {

    if (c_used == 256) {
      clear_array();
      c_used = 0;
    }

    random = number_range(0, 255);    // use all ASCII values

    if ( *(place_holder + random) ) {  // already used, find another
      done = 0;
      while (!done) {
        random = number_range(0, 255);
        if ( *(place_holder + random) == 0) {
          *(place_holder + random) = 1;
          done = 1;
        }
      }         
    }
    else *(place_holder + random) = 1;  // use it and mark as used 

    c_used++;   // found next character so increment counter

    sprintf(buffer, "%c", random);  // convert ASCII value to char 
    ch = buffer[0];
    fputc(ch, fp); // write to file
  }

  fclose(fp);

  printf("\nDone. File \"random.bin\" was created (size: %ld bytes)", byte_size);
  printf("\nOutput file is in the root directory (c:\\random.bin)\n");
  return(0);
}

// ---------------------------------------------------------------------------------

void clear_array()
{
  register int x;
  for (x = 0; x < 256; x++) 
    *(place_holder + x) = 0;
}

// ---------------------------------------------------------------------------------

int number_mm()
{
    int *piState;
    int iState1;
    int iState2;
    int iRand;

    piState     = &rgiState[2];
    iState1     = piState[-2];
    iState2     = piState[-1];
    iRand       = ( piState[iState1] + piState[iState2] )
                & ( ( 1 << 30 ) - 1 );
    piState[iState1]    = iRand;

    if ( ++iState1 == 55 )  iState1 = 0;
    if ( ++iState2 == 55 )  iState2 = 0;

    piState[-2]     = iState1;
    piState[-1]     = iState2;

    return(iRand >> 6);
}

// ---------------------------------------------------------------------------------

//  Generate a random number.

int number_range( int minval, int maxval )
{
  int power, number;

  if ( ( maxval = maxval - minval + 1 ) <= 1 ) return (minval);

  for ( power = 2; power < maxval; power <<= 1 )
    ;
  while ( ( number = number_mm( ) & ( power - 1 ) ) >= maxval )
    ;
  return(minval + number);
}

// ---------------------------------------------------------------------------------

// Mitchell-Moore algorithm from Knuth Volume II. 

void init_mm( )
{
  int *piState;
  int iState;

  piState = &rgiState[2];
  piState[-2]   = 55 - 55;
  piState[-1]   = 55 - 24;
  piState[0]    = ( (int) time( NULL ) ) & ( ( 1 << 30 ) - 1 );
  piState[1]    = 1;

  for ( iState = 2; iState < 55; iState++ ) 
  {
    piState[iState] = ( piState[iState-1] + piState[iState-2] )
                      &  ( ( 1 << 30 ) - 1 );
  }
}

// -------------------- End -------------------------------------------------------
Share
Improve this answer
Follow
answered Aug 10, 2016 at 13:38
Rubenisme's user avatar
Rubenisme
78711 gold badge88 silver badges1515 bronze badges
Add a comment
1

So, i decided to add an accurate answer this time.

language is powershell. assumptions: filenames will be sequential and not random. file contents are to be cryptographically secure and unique. file location to be C:\temp\

#create a fixed size byte array for later use.  make it the required file size.
$bytearray = New-Object byte[] 2048

#create and start a stopwatch object to measure how long it all takes.
$stopwatch = [Diagnostics.Stopwatch]::StartNew()

#create a CSRNG object
$RNGObject = New-Object Security.Cryptography.RNGCryptoServiceProvider

# set up a loop to run 50000 times
0..49999 | Foreach-Object {

    # create a file stream handle with a name format 'filennnnn'
    $stream = New-Object System.IO.FileStream("c:\temp\file$("{0:D5}" -f $_)"), Create

    # and a stream writer handle
    $writer = New-Object System.IO.BinaryWriter($stream)

    # Fill our array from the CSRNG
    $RNGObject.GetNonZeroBytes($bytearray)

    # Append to the current file
    $writer.write($bytearray)

    # Close the stream
    $stream.close()

}
About
Products
For Teams
Search…
Join Stack Overflow to find the best answer to your technical question, help others answer theirs.

Home
PUBLIC
Questions
Tags
Users
Companies
COLLECTIVES
Explore Collectives
TEAMS
Stack Overflow for Teams – Start collaborating and sharing organizational knowledge. 
Generating Random Files in Windows
Asked 14 years, 3 months ago
Modified 5 months ago
Viewed 85k times
42

Does anyone have a way to generate files of random data in Windows? I would like to generate 50,000 small (2K) files as an example.

windows
Share
Improve this question
Follow
asked Feb 10, 2009 at 18:51
Jeff
2
Could you share with us whether you want text files or binary files? Could you also comment as to what programming languages you have access to (if any)? Do you have MS Office installed? Also, not very relevant, but what version of windows are you using? – 
user62572
 Feb 10, 2009 at 20:05
Add a comment
16 Answers
Sorted by:

Highest score (default)
34

You can run fsutil in a batch loop to create files of any size.

fsutil file createnew filename.extension 2000
Share
Improve this answer
Follow
answered Feb 10, 2009 at 19:01
Bogdan's user avatar
Bogdan
3,03511 gold badge2222 silver badges2020 bronze badges
I just found that utility. Didn't know it existed before. thebackroomtech.com/2009/01/16/… – 
beach
 Feb 10, 2009 at 19:04
41
However, it doesn't create random data. Just blank files. – 
beach
 Feb 10, 2009 at 19:07
And it seems to require admin permissions. Going with the powershell. – 
Mathias Mamsch
 Oct 25, 2017 at 7:21
Add a comment
21

One-liner in Powershell:

$out = new-object byte[] 1048576; (new-object Random).NextBytes($out); [IO.File]::WriteAllBytes('d:\file.bin', $out)
This is lightning fast, compared to @user188737 solution.

Share
Improve this answer
Follow
answered Sep 26, 2017 at 7:07
gwiazdorrr's user avatar
gwiazdorrr
6,16122 gold badges2727 silver badges3636 bronze badges
1
Every single file that this one liner creates is identical. Is there any way to make the content of each file different – 
Dhiwakar Ravikumar
 Apr 15, 2018 at 4:47
3
Are you sure this is the case? I tried it on my system, ran it 3 times, got 3 distinct files. The constructor for the Random type is by default based on the system time, so perhaps if you run this multiple times in very quick succession, you might get identical files. You could avoid this by creating a single Random object and then reusing it for each consecutive file: $rnd = New-Object Random; once at the top, and then $rnd.NextBytes instead of (New-Object Random).NextBytes when generating the file. – 
Jonathan Gilbert
 May 29, 2018 at 16:19
Add a comment
18

You can use PowerShell to generate cheap random data for your files:

[Byte[]] $out = @()
0..2047 | % {$out += Get-Random -Minimum 0 -Maximum 255}
[System.IO.File]::WriteAllBytes("myrandomfiletest", $out)
This uses an algorithm with a seed taken from the system clock, so don't use this for ANY serious cryptographic applications.

In addition, be wary of the performance degradation of Get-Random when increasing the size of the output file. More on this aspect here:

PowerShell random file generator too slow
Improve Powershell Performance to Generate a Random File
Share
Improve this answer
Follow
edited May 23, 2017 at 12:32
Community's user avatar
CommunityBot
111 silver badge
answered Sep 27, 2013 at 18:23
Gerrit's user avatar
Gerrit
85166 silver badges1111 bronze badges
Add a comment
16

I have been using Random Data File Creator and liking it, it creates binary files (i.e. not text files) filled with pseudo-random bits, it can quickly create very large files. To use it to create multiple small files you would need to script it, which would be very easy given it is command line.

Share
Improve this answer
Follow
edited Dec 25, 2015 at 11:57
mguassa's user avatar
mguassa
3,97122 gold badges1414 silver badges1919 bronze badges
answered Feb 5, 2010 at 19:20
David Waters's user avatar
David Waters
11.9k77 gold badges4141 silver badges7676 bronze badges
There are quite a few programs and cloud tools of this nature: raywoodcockslatest.wordpress.com/2021/08/21/dummy-files – 
Ray Woodcock
 May 17, 2022 at 14:08
Add a comment
8

Since you don't specify a language, I'll simply pick one at random. Here is a powershell script to do it:

$rootDir = 'C:\Temp\TestRandomFiles\'
$baseFile = $rootDir + "base.txt"
$desiredFileSize = 2*1KB
$fileCount = 50000
"start" | Out-File -Filepath $baseFile
While ($(Get-ChildItem -path $baseFile).Length -lt $desiredFileSize)
{
    $(Get-ChildItem -path $baseFile).Length | Out-File $baseFile -APPEND
}
for($i=1;$i -lt $fileCount;$i++)
{
    Copy-Item $baseFile "File$i.txt"
}
You'll have to change the variables to the parameters that you want of course.

Share
Improve this answer
Follow
answered Feb 10, 2009 at 19:47
EBGreen's user avatar
EBGreen
36.5k1212 gold badges6464 silver badges8484 bronze badges
1
oops...missed the random data requirement. Is that important? If so I can tweak it. – 
EBGreen
 Feb 10, 2009 at 19:48
1
If you are a PS whiz, I don't suppose you can do random data as I am keen to learn how this done! – 
Wil
 Jan 27, 2012 at 10:22 
I'm definitely not a whiz, but there are several ways. Basically you identify the data set that you want to randomize (say 0-9 and a-Z) then you randomly pick from that set to build the data for the file, then write it out to the file. If I have a chance later today, I'll alter the above code to use random data. – 
EBGreen
 Jan 27, 2012 at 15:12
@EBGreen thank You much! Best regards – 
Gennady G
 Nov 29, 2021 at 14:01
Add a comment
4

Instead of using Get-Random to generate the text as per user188737 & mguassa suggestions, I improved the speed by using GUIDs.

Function New-RandomFile {
    Param(
        $Path = '.', 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 
    (1..($FileSize/128)).foreach({-join ([guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-").SubString(1, 126) }) | set-content "$Path\$FileName"
}
This took 491 milliseconds to generate a 1mb file. Running:

New-RandomFile -FileSize 1mb
UPDATE:

I've updated my function to use a ScriptBlock, so you can replace the 'NewGuid()' method with anything you want.

In this scenario, I make 1kb chunks, since I know I'm never creating smaller files. This improved the speed of my function drastically!

Set-Content forces a NewLine at the end, which is why you need to remove 2 Characters each time you write to file. I've replaced it with [io.file]::WriteAllText() instead.

Function New-RandomFile_1kChunks {
    Param(
        $Path = (Resolve-Path '.').Path, 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 

    $Chunk = { [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-" }

    $Chunks = [math]::Ceiling($FileSize/1kb)

    [io.file]::WriteAllText("$Path\$FileName","$(-Join (1..($Chunks)).foreach({ $Chunk.Invoke() }))")

    Write-Warning "New-RandomFile: $Path\$FileName"

}
If you dont care that all chunks are random, you can simply Invoke() the generation of the 1kb chunk once.. this improves the speed drastically, but won't make the entire file random.

Function New-RandomFile_Fast {
    Param(
        $Path = (Resolve-Path '.').Path, 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 

    $Chunk = { [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-" }
    $Chunks = [math]::Ceiling($FileSize/1kb)
    $ChunkString = $Chunk.Invoke()

    [io.file]::WriteAllText("$Path\$FileName","$(-Join (1..($Chunks)).foreach({ $ChunkString }))")

    Write-Warning "New-RandomFile: $Path\$FileName"

}
Measure-Command all these changes to generate a 10mb file:

Executing New-RandomFile: 35.7688241 seconds.

Executing New-RandomFile_1kChunks: 25.1463777 seconds.

Executing New-RandomFile_Fast: 1.1626236 seconds.

Share
Improve this answer
Follow
edited Apr 3, 2017 at 23:04
answered Apr 1, 2017 at 2:39
Marc Kellerman's user avatar
Marc Kellerman
45622 silver badges1010 bronze badges
Add a comment
2

You'll have to create files in the normal way, and then populate them with randomized data, probably from a rand() function of some sort.

It really depends on your programming language. Windows itself certainly won't provide this capability.

There are a number of programming languages that could do this easily, however, including basic windows batch/CMD scripts. What language are you interested in using?

Share
Improve this answer
Follow
answered Feb 10, 2009 at 18:54
levand's user avatar
levand
8,39033 gold badges4040 silver badges5454 bronze badges
Add a comment
2

None of the answers here were cutting it for me, so here's a script which takes advantage of the Cryptography library to generate lots of random files.

This will generate files very quickly until your system's entropy is exhausted (on my PC this was about 4,000 files). After this it (and any other applications on your system that need cryptographic random numbers) will run very slowly. (In Linux terms, consider this script to use /dev/random instead of /dev/urandom)

$directory = (Get-Location).Path;
0..10000 | ForEach-Object {
    $size = 1023 * (Get-Random -Minimum 10 -Maximum 1536);
    $contents = [Byte[]]::new($size);

    $rng = [System.Security.Cryptography.RNGCryptoServiceProvider]::new();
    $rng.GetBytes($contents);

    $filename = "$directory\random$($_.ToString().PadLeft(5, '0')).txt"
    Write-Host $filename
    [System.IO.File]::WriteAllBytes($filename, $contents)
}
If you'd rather not deplete your system's entropy, replace the two $rng lines with these:

    $rng = [System.Random]::new();
    $rng.NextBytes($contents);
This will run much slower, but for large quantities of files (or larger files) it should be more reliable.

Share
Improve this answer
Follow
answered Apr 15, 2020 at 0:57
Joshua Walsh's user avatar
Joshua Walsh
1,88555 gold badges2525 silver badges5050 bronze badges
Add a comment
1

Yes, fsutil is great, but doesn't generate random data, just ASCII nulls.

I don't remember where I found this but searching on google these days I can still find it at: http://www.private-files.com/other/random.c.txt

I don't know how old this program is but at least as old as your question, probably somewhat older.

Anyway here's a program in C which creates files with a chi-squared test result of 0:

// ------------------------------------------------------------     
// Name: random.c  (program to create random files)
//     
// This "no-frills" program creates files with the following 
// characteristics: 
//
//    (1) Byte sequences are random (no predictability);
//    (2) Files produced are binary files; 
//    (3) File sizes are multiples of 256; 
//    (4) Files will have a chi-squared test result of 0
//        (see analyze.exe by Wenger for explanation)
//  
//              Programmer:  Scott Wenger
//                           Box 802
//                           Stevens Point, WI 54481
//                           panther@wctc.net
//
//       Note:  part of this code is from Knuth Volume II
// 
//  Enhancements and modifications of this program are left 
//  to the imagination and creativity of the programmer.
//  Check your compiler for required header files.  You may 
//  need to include the iostream header.
//
//  Random files are of potential use to cryptographers
//  for the purpose of encryption.  
//  
//  To analyze files produced by this program, see 
//  the analyze.exe program by Scott Wenger (found at
//  http://www.coredcs.com/sware.html)
// ------------------------------------------------------------


// This program works in the following way:
// The time is used to seed the random number generator.
// Using Knuth's algorithm, random numbers are generated
// in the range of 0 to 255 (corresponding to 256 ASCII chars.)
// When random numbers are generated they are marked as used and 
// are not re-used until all 256 ASCII values appear.  Characters 
// are written to disk and the process continues until the
// desired file size is reached.  Output is a random binary file
// called random.bin (placed in the root directory)
// The controlled filesize along with the placeholder feature 
// of this code forces a very high degree of randomness in 
// the output file. 

#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void init_mm();
void clear_array(); 
int  number_range(int minval, int maxval);
int  number_mm();

static int rgiState[2 + 55]; 
int place_holder[256];          // to keep track of numbers already generated

int main()
{
  mainprogram();
  return 0;
}

int mainprogram()
{
  int ch; 
  int c_used = 0;  // counter of chars in placeholder
  int done = 0; 
  int random;

  char buffer[2];

  long x;
  long byte_size = 0L;
  FILE *fp;

  clear_array();
  init_mm();  // seed random number generator

  // create a random file of length specified by user
  printf("\nrandom.exe originally by Scott Wenger");
  printf("\nThis program creates a random binary file.\n");
  printf("\nPlease specify length of random file to create (in megabytes): ");  

  scanf("%ld", &byte_size);

  while (byte_size > 1000 || byte_size <= 0 )
  {
    printf("\nWill not create files larger than a gigabyte! ");
    printf("\nPlease specify length of random file to create (in megabytes): ");
    flushall();
    scanf("%ld", &byte_size);
  }

  byte_size = byte_size * 1024 * 1024;

  if ( (fp = fopen("random.bin", "wb"))  == NULL) {
    fprintf(stderr, "\nOutput file (random.bin) could not be created.");      
    fflush(stdout);
    exit(1);
  }

  for (x = 0L; x < byte_size; x++) {

    if (c_used == 256) {
      clear_array();
      c_used = 0;
    }

    random = number_range(0, 255);    // use all ASCII values

    if ( *(place_holder + random) ) {  // already used, find another
      done = 0;
      while (!done) {
        random = number_range(0, 255);
        if ( *(place_holder + random) == 0) {
          *(place_holder + random) = 1;
          done = 1;
        }
      }         
    }
    else *(place_holder + random) = 1;  // use it and mark as used 

    c_used++;   // found next character so increment counter

    sprintf(buffer, "%c", random);  // convert ASCII value to char 
    ch = buffer[0];
    fputc(ch, fp); // write to file
  }

  fclose(fp);

  printf("\nDone. File \"random.bin\" was created (size: %ld bytes)", byte_size);
  printf("\nOutput file is in the root directory (c:\\random.bin)\n");
  return(0);
}

// ---------------------------------------------------------------------------------

void clear_array()
{
  register int x;
  for (x = 0; x < 256; x++) 
    *(place_holder + x) = 0;
}

// ---------------------------------------------------------------------------------

int number_mm()
{
    int *piState;
    int iState1;
    int iState2;
    int iRand;

    piState     = &rgiState[2];
    iState1     = piState[-2];
    iState2     = piState[-1];
    iRand       = ( piState[iState1] + piState[iState2] )
                & ( ( 1 << 30 ) - 1 );
    piState[iState1]    = iRand;

    if ( ++iState1 == 55 )  iState1 = 0;
    if ( ++iState2 == 55 )  iState2 = 0;

    piState[-2]     = iState1;
    piState[-1]     = iState2;

    return(iRand >> 6);
}

// ---------------------------------------------------------------------------------

//  Generate a random number.

int number_range( int minval, int maxval )
{
  int power, number;

  if ( ( maxval = maxval - minval + 1 ) <= 1 ) return (minval);

  for ( power = 2; power < maxval; power <<= 1 )
    ;
  while ( ( number = number_mm( ) & ( power - 1 ) ) >= maxval )
    ;
  return(minval + number);
}

// ---------------------------------------------------------------------------------

// Mitchell-Moore algorithm from Knuth Volume II. 

void init_mm( )
{
  int *piState;
  int iState;

  piState = &rgiState[2];
  piState[-2]   = 55 - 55;
  piState[-1]   = 55 - 24;
  piState[0]    = ( (int) time( NULL ) ) & ( ( 1 << 30 ) - 1 );
  piState[1]    = 1;

  for ( iState = 2; iState < 55; iState++ ) 
  {
    piState[iState] = ( piState[iState-1] + piState[iState-2] )
                      &  ( ( 1 << 30 ) - 1 );
  }
}

// -------------------- End -------------------------------------------------------
Share
Improve this answer
Follow
answered Aug 10, 2016 at 13:38
Rubenisme's user avatar
Rubenisme
78711 gold badge88 silver badges1515 bronze badges
Add a comment
1

So, i decided to add an accurate answer this time.

language is powershell. assumptions: filenames will be sequential and not random. file contents are to be cryptographically secure and unique. file location to be C:\temp\

#create a fixed size byte array for later use.  make it the required file size.
$bytearray = New-Object byte[] 2048

#create and start a stopwatch object to measure how long it all takes.
$stopwatch = [Diagnostics.Stopwatch]::StartNew()

#create a CSRNG object
$RNGObject = New-Object Security.Cryptography.RNGCryptoServiceProvider

# set up a loop to run 50000 times
0..49999 | Foreach-Object {

    # create a file stream handle with a name format 'filennnnn'
    $stream = New-Object System.IO.FileStream("c:\temp\file$("{0:D5}" -f $_)"), Create

    # and a stream writer handle
    $writer = New-Object System.IO.BinaryWriter($stream)

    # Fill our array from the CSRNG
    $RNGObject.GetNonZeroBytes($bytearray)

    # Append to the current file
    $writer.write($bytearray)

    # Close the stream
    $stream.close()

}
About
Products
For Teams
Search…
Join Stack Overflow to find the best answer to your technical question, help others answer theirs.

Home
PUBLIC
Questions
Tags
Users
Companies
COLLECTIVES
Explore Collectives
TEAMS
Stack Overflow for Teams – Start collaborating and sharing organizational knowledge. 
Generating Random Files in Windows
Asked 14 years, 3 months ago
Modified 5 months ago
Viewed 85k times
42

Does anyone have a way to generate files of random data in Windows? I would like to generate 50,000 small (2K) files as an example.

windows
Share
Improve this question
Follow
asked Feb 10, 2009 at 18:51
Jeff
2
Could you share with us whether you want text files or binary files? Could you also comment as to what programming languages you have access to (if any)? Do you have MS Office installed? Also, not very relevant, but what version of windows are you using? – 
user62572
 Feb 10, 2009 at 20:05
Add a comment
16 Answers
Sorted by:

Highest score (default)
34

You can run fsutil in a batch loop to create files of any size.

fsutil file createnew filename.extension 2000
Share
Improve this answer
Follow
answered Feb 10, 2009 at 19:01
Bogdan's user avatar
Bogdan
3,03511 gold badge2222 silver badges2020 bronze badges
I just found that utility. Didn't know it existed before. thebackroomtech.com/2009/01/16/… – 
beach
 Feb 10, 2009 at 19:04
41
However, it doesn't create random data. Just blank files. – 
beach
 Feb 10, 2009 at 19:07
And it seems to require admin permissions. Going with the powershell. – 
Mathias Mamsch
 Oct 25, 2017 at 7:21
Add a comment
21

One-liner in Powershell:

$out = new-object byte[] 1048576; (new-object Random).NextBytes($out); [IO.File]::WriteAllBytes('d:\file.bin', $out)
This is lightning fast, compared to @user188737 solution.

Share
Improve this answer
Follow
answered Sep 26, 2017 at 7:07
gwiazdorrr's user avatar
gwiazdorrr
6,16122 gold badges2727 silver badges3636 bronze badges
1
Every single file that this one liner creates is identical. Is there any way to make the content of each file different – 
Dhiwakar Ravikumar
 Apr 15, 2018 at 4:47
3
Are you sure this is the case? I tried it on my system, ran it 3 times, got 3 distinct files. The constructor for the Random type is by default based on the system time, so perhaps if you run this multiple times in very quick succession, you might get identical files. You could avoid this by creating a single Random object and then reusing it for each consecutive file: $rnd = New-Object Random; once at the top, and then $rnd.NextBytes instead of (New-Object Random).NextBytes when generating the file. – 
Jonathan Gilbert
 May 29, 2018 at 16:19
Add a comment
18

You can use PowerShell to generate cheap random data for your files:

[Byte[]] $out = @()
0..2047 | % {$out += Get-Random -Minimum 0 -Maximum 255}
[System.IO.File]::WriteAllBytes("myrandomfiletest", $out)
This uses an algorithm with a seed taken from the system clock, so don't use this for ANY serious cryptographic applications.

In addition, be wary of the performance degradation of Get-Random when increasing the size of the output file. More on this aspect here:

PowerShell random file generator too slow
Improve Powershell Performance to Generate a Random File
Share
Improve this answer
Follow
edited May 23, 2017 at 12:32
Community's user avatar
CommunityBot
111 silver badge
answered Sep 27, 2013 at 18:23
Gerrit's user avatar
Gerrit
85166 silver badges1111 bronze badges
Add a comment
16

I have been using Random Data File Creator and liking it, it creates binary files (i.e. not text files) filled with pseudo-random bits, it can quickly create very large files. To use it to create multiple small files you would need to script it, which would be very easy given it is command line.

Share
Improve this answer
Follow
edited Dec 25, 2015 at 11:57
mguassa's user avatar
mguassa
3,97122 gold badges1414 silver badges1919 bronze badges
answered Feb 5, 2010 at 19:20
David Waters's user avatar
David Waters
11.9k77 gold badges4141 silver badges7676 bronze badges
There are quite a few programs and cloud tools of this nature: raywoodcockslatest.wordpress.com/2021/08/21/dummy-files – 
Ray Woodcock
 May 17, 2022 at 14:08
Add a comment
8

Since you don't specify a language, I'll simply pick one at random. Here is a powershell script to do it:

$rootDir = 'C:\Temp\TestRandomFiles\'
$baseFile = $rootDir + "base.txt"
$desiredFileSize = 2*1KB
$fileCount = 50000
"start" | Out-File -Filepath $baseFile
While ($(Get-ChildItem -path $baseFile).Length -lt $desiredFileSize)
{
    $(Get-ChildItem -path $baseFile).Length | Out-File $baseFile -APPEND
}
for($i=1;$i -lt $fileCount;$i++)
{
    Copy-Item $baseFile "File$i.txt"
}
You'll have to change the variables to the parameters that you want of course.

Share
Improve this answer
Follow
answered Feb 10, 2009 at 19:47
EBGreen's user avatar
EBGreen
36.5k1212 gold badges6464 silver badges8484 bronze badges
1
oops...missed the random data requirement. Is that important? If so I can tweak it. – 
EBGreen
 Feb 10, 2009 at 19:48
1
If you are a PS whiz, I don't suppose you can do random data as I am keen to learn how this done! – 
Wil
 Jan 27, 2012 at 10:22 
I'm definitely not a whiz, but there are several ways. Basically you identify the data set that you want to randomize (say 0-9 and a-Z) then you randomly pick from that set to build the data for the file, then write it out to the file. If I have a chance later today, I'll alter the above code to use random data. – 
EBGreen
 Jan 27, 2012 at 15:12
@EBGreen thank You much! Best regards – 
Gennady G
 Nov 29, 2021 at 14:01
Add a comment
4

Instead of using Get-Random to generate the text as per user188737 & mguassa suggestions, I improved the speed by using GUIDs.

Function New-RandomFile {
    Param(
        $Path = '.', 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 
    (1..($FileSize/128)).foreach({-join ([guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-").SubString(1, 126) }) | set-content "$Path\$FileName"
}
This took 491 milliseconds to generate a 1mb file. Running:

New-RandomFile -FileSize 1mb
UPDATE:

I've updated my function to use a ScriptBlock, so you can replace the 'NewGuid()' method with anything you want.

In this scenario, I make 1kb chunks, since I know I'm never creating smaller files. This improved the speed of my function drastically!

Set-Content forces a NewLine at the end, which is why you need to remove 2 Characters each time you write to file. I've replaced it with [io.file]::WriteAllText() instead.

Function New-RandomFile_1kChunks {
    Param(
        $Path = (Resolve-Path '.').Path, 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 

    $Chunk = { [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-" }

    $Chunks = [math]::Ceiling($FileSize/1kb)

    [io.file]::WriteAllText("$Path\$FileName","$(-Join (1..($Chunks)).foreach({ $Chunk.Invoke() }))")

    Write-Warning "New-RandomFile: $Path\$FileName"

}
If you dont care that all chunks are random, you can simply Invoke() the generation of the 1kb chunk once.. this improves the speed drastically, but won't make the entire file random.

Function New-RandomFile_Fast {
    Param(
        $Path = (Resolve-Path '.').Path, 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 

    $Chunk = { [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-" }
    $Chunks = [math]::Ceiling($FileSize/1kb)
    $ChunkString = $Chunk.Invoke()

    [io.file]::WriteAllText("$Path\$FileName","$(-Join (1..($Chunks)).foreach({ $ChunkString }))")

    Write-Warning "New-RandomFile: $Path\$FileName"

}
Measure-Command all these changes to generate a 10mb file:

Executing New-RandomFile: 35.7688241 seconds.

Executing New-RandomFile_1kChunks: 25.1463777 seconds.

Executing New-RandomFile_Fast: 1.1626236 seconds.

Share
Improve this answer
Follow
edited Apr 3, 2017 at 23:04
answered Apr 1, 2017 at 2:39
Marc Kellerman's user avatar
Marc Kellerman
45622 silver badges1010 bronze badges
Add a comment
2

You'll have to create files in the normal way, and then populate them with randomized data, probably from a rand() function of some sort.

It really depends on your programming language. Windows itself certainly won't provide this capability.

There are a number of programming languages that could do this easily, however, including basic windows batch/CMD scripts. What language are you interested in using?

Share
Improve this answer
Follow
answered Feb 10, 2009 at 18:54
levand's user avatar
levand
8,39033 gold badges4040 silver badges5454 bronze badges
Add a comment
2

None of the answers here were cutting it for me, so here's a script which takes advantage of the Cryptography library to generate lots of random files.

This will generate files very quickly until your system's entropy is exhausted (on my PC this was about 4,000 files). After this it (and any other applications on your system that need cryptographic random numbers) will run very slowly. (In Linux terms, consider this script to use /dev/random instead of /dev/urandom)

$directory = (Get-Location).Path;
0..10000 | ForEach-Object {
    $size = 1023 * (Get-Random -Minimum 10 -Maximum 1536);
    $contents = [Byte[]]::new($size);

    $rng = [System.Security.Cryptography.RNGCryptoServiceProvider]::new();
    $rng.GetBytes($contents);

    $filename = "$directory\random$($_.ToString().PadLeft(5, '0')).txt"
    Write-Host $filename
    [System.IO.File]::WriteAllBytes($filename, $contents)
}
If you'd rather not deplete your system's entropy, replace the two $rng lines with these:

    $rng = [System.Random]::new();
    $rng.NextBytes($contents);
This will run much slower, but for large quantities of files (or larger files) it should be more reliable.

Share
Improve this answer
Follow
answered Apr 15, 2020 at 0:57
Joshua Walsh's user avatar
Joshua Walsh
1,88555 gold badges2525 silver badges5050 bronze badges
Add a comment
1

Yes, fsutil is great, but doesn't generate random data, just ASCII nulls.

I don't remember where I found this but searching on google these days I can still find it at: http://www.private-files.com/other/random.c.txt

I don't know how old this program is but at least as old as your question, probably somewhat older.

Anyway here's a program in C which creates files with a chi-squared test result of 0:

// ------------------------------------------------------------     
// Name: random.c  (program to create random files)
//     
// This "no-frills" program creates files with the following 
// characteristics: 
//
//    (1) Byte sequences are random (no predictability);
//    (2) Files produced are binary files; 
//    (3) File sizes are multiples of 256; 
//    (4) Files will have a chi-squared test result of 0
//        (see analyze.exe by Wenger for explanation)
//  
//              Programmer:  Scott Wenger
//                           Box 802
//                           Stevens Point, WI 54481
//                           panther@wctc.net
//
//       Note:  part of this code is from Knuth Volume II
// 
//  Enhancements and modifications of this program are left 
//  to the imagination and creativity of the programmer.
//  Check your compiler for required header files.  You may 
//  need to include the iostream header.
//
//  Random files are of potential use to cryptographers
//  for the purpose of encryption.  
//  
//  To analyze files produced by this program, see 
//  the analyze.exe program by Scott Wenger (found at
//  http://www.coredcs.com/sware.html)
// ------------------------------------------------------------


// This program works in the following way:
// The time is used to seed the random number generator.
// Using Knuth's algorithm, random numbers are generated
// in the range of 0 to 255 (corresponding to 256 ASCII chars.)
// When random numbers are generated they are marked as used and 
// are not re-used until all 256 ASCII values appear.  Characters 
// are written to disk and the process continues until the
// desired file size is reached.  Output is a random binary file
// called random.bin (placed in the root directory)
// The controlled filesize along with the placeholder feature 
// of this code forces a very high degree of randomness in 
// the output file. 

#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void init_mm();
void clear_array(); 
int  number_range(int minval, int maxval);
int  number_mm();

static int rgiState[2 + 55]; 
int place_holder[256];          // to keep track of numbers already generated

int main()
{
  mainprogram();
  return 0;
}

int mainprogram()
{
  int ch; 
  int c_used = 0;  // counter of chars in placeholder
  int done = 0; 
  int random;

  char buffer[2];

  long x;
  long byte_size = 0L;
  FILE *fp;

  clear_array();
  init_mm();  // seed random number generator

  // create a random file of length specified by user
  printf("\nrandom.exe originally by Scott Wenger");
  printf("\nThis program creates a random binary file.\n");
  printf("\nPlease specify length of random file to create (in megabytes): ");  

  scanf("%ld", &byte_size);

  while (byte_size > 1000 || byte_size <= 0 )
  {
    printf("\nWill not create files larger than a gigabyte! ");
    printf("\nPlease specify length of random file to create (in megabytes): ");
    flushall();
    scanf("%ld", &byte_size);
  }

  byte_size = byte_size * 1024 * 1024;

  if ( (fp = fopen("random.bin", "wb"))  == NULL) {
    fprintf(stderr, "\nOutput file (random.bin) could not be created.");      
    fflush(stdout);
    exit(1);
  }

  for (x = 0L; x < byte_size; x++) {

    if (c_used == 256) {
      clear_array();
      c_used = 0;
    }

    random = number_range(0, 255);    // use all ASCII values

    if ( *(place_holder + random) ) {  // already used, find another
      done = 0;
      while (!done) {
        random = number_range(0, 255);
        if ( *(place_holder + random) == 0) {
          *(place_holder + random) = 1;
          done = 1;
        }
      }         
    }
    else *(place_holder + random) = 1;  // use it and mark as used 

    c_used++;   // found next character so increment counter

    sprintf(buffer, "%c", random);  // convert ASCII value to char 
    ch = buffer[0];
    fputc(ch, fp); // write to file
  }

  fclose(fp);

  printf("\nDone. File \"random.bin\" was created (size: %ld bytes)", byte_size);
  printf("\nOutput file is in the root directory (c:\\random.bin)\n");
  return(0);
}

// ---------------------------------------------------------------------------------

void clear_array()
{
  register int x;
  for (x = 0; x < 256; x++) 
    *(place_holder + x) = 0;
}

// ---------------------------------------------------------------------------------

int number_mm()
{
    int *piState;
    int iState1;
    int iState2;
    int iRand;

    piState     = &rgiState[2];
    iState1     = piState[-2];
    iState2     = piState[-1];
    iRand       = ( piState[iState1] + piState[iState2] )
                & ( ( 1 << 30 ) - 1 );
    piState[iState1]    = iRand;

    if ( ++iState1 == 55 )  iState1 = 0;
    if ( ++iState2 == 55 )  iState2 = 0;

    piState[-2]     = iState1;
    piState[-1]     = iState2;

    return(iRand >> 6);
}

// ---------------------------------------------------------------------------------

//  Generate a random number.

int number_range( int minval, int maxval )
{
  int power, number;

  if ( ( maxval = maxval - minval + 1 ) <= 1 ) return (minval);

  for ( power = 2; power < maxval; power <<= 1 )
    ;
  while ( ( number = number_mm( ) & ( power - 1 ) ) >= maxval )
    ;
  return(minval + number);
}

// ---------------------------------------------------------------------------------

// Mitchell-Moore algorithm from Knuth Volume II. 

void init_mm( )
{
  int *piState;
  int iState;

  piState = &rgiState[2];
  piState[-2]   = 55 - 55;
  piState[-1]   = 55 - 24;
  piState[0]    = ( (int) time( NULL ) ) & ( ( 1 << 30 ) - 1 );
  piState[1]    = 1;

  for ( iState = 2; iState < 55; iState++ ) 
  {
    piState[iState] = ( piState[iState-1] + piState[iState-2] )
                      &  ( ( 1 << 30 ) - 1 );
  }
}

// -------------------- End -------------------------------------------------------
Share
Improve this answer
Follow
answered Aug 10, 2016 at 13:38
Rubenisme's user avatar
Rubenisme
78711 gold badge88 silver badges1515 bronze badges
Add a comment
1

So, i decided to add an accurate answer this time.

language is powershell. assumptions: filenames will be sequential and not random. file contents are to be cryptographically secure and unique. file location to be C:\temp\

#create a fixed size byte array for later use.  make it the required file size.
$bytearray = New-Object byte[] 2048

#create and start a stopwatch object to measure how long it all takes.
$stopwatch = [Diagnostics.Stopwatch]::StartNew()

#create a CSRNG object
$RNGObject = New-Object Security.Cryptography.RNGCryptoServiceProvider

# set up a loop to run 50000 times
0..49999 | Foreach-Object {

    # create a file stream handle with a name format 'filennnnn'
    $stream = New-Object System.IO.FileStream("c:\temp\file$("{0:D5}" -f $_)"), Create

    # and a stream writer handle
    $writer = New-Object System.IO.BinaryWriter($stream)

    # Fill our array from the CSRNG
    $RNGObject.GetNonZeroBytes($bytearray)

    # Append to the current file
    $writer.write($bytearray)

    # Close the stream
    $stream.close()

}
About
Products
For Teams
Search…
Join Stack Overflow to find the best answer to your technical question, help others answer theirs.

Home
PUBLIC
Questions
Tags
Users
Companies
COLLECTIVES
Explore Collectives
TEAMS
Stack Overflow for Teams – Start collaborating and sharing organizational knowledge. 
Generating Random Files in Windows
Asked 14 years, 3 months ago
Modified 5 months ago
Viewed 85k times
42

Does anyone have a way to generate files of random data in Windows? I would like to generate 50,000 small (2K) files as an example.

windows
Share
Improve this question
Follow
asked Feb 10, 2009 at 18:51
Jeff
2
Could you share with us whether you want text files or binary files? Could you also comment as to what programming languages you have access to (if any)? Do you have MS Office installed? Also, not very relevant, but what version of windows are you using? – 
user62572
 Feb 10, 2009 at 20:05
Add a comment
16 Answers
Sorted by:

Highest score (default)
34

You can run fsutil in a batch loop to create files of any size.

fsutil file createnew filename.extension 2000
Share
Improve this answer
Follow
answered Feb 10, 2009 at 19:01
Bogdan's user avatar
Bogdan
3,03511 gold badge2222 silver badges2020 bronze badges
I just found that utility. Didn't know it existed before. thebackroomtech.com/2009/01/16/… – 
beach
 Feb 10, 2009 at 19:04
41
However, it doesn't create random data. Just blank files. – 
beach
 Feb 10, 2009 at 19:07
And it seems to require admin permissions. Going with the powershell. – 
Mathias Mamsch
 Oct 25, 2017 at 7:21
Add a comment
21

One-liner in Powershell:

$out = new-object byte[] 1048576; (new-object Random).NextBytes($out); [IO.File]::WriteAllBytes('d:\file.bin', $out)
This is lightning fast, compared to @user188737 solution.

Share
Improve this answer
Follow
answered Sep 26, 2017 at 7:07
gwiazdorrr's user avatar
gwiazdorrr
6,16122 gold badges2727 silver badges3636 bronze badges
1
Every single file that this one liner creates is identical. Is there any way to make the content of each file different – 
Dhiwakar Ravikumar
 Apr 15, 2018 at 4:47
3
Are you sure this is the case? I tried it on my system, ran it 3 times, got 3 distinct files. The constructor for the Random type is by default based on the system time, so perhaps if you run this multiple times in very quick succession, you might get identical files. You could avoid this by creating a single Random object and then reusing it for each consecutive file: $rnd = New-Object Random; once at the top, and then $rnd.NextBytes instead of (New-Object Random).NextBytes when generating the file. – 
Jonathan Gilbert
 May 29, 2018 at 16:19
Add a comment
18

You can use PowerShell to generate cheap random data for your files:

[Byte[]] $out = @()
0..2047 | % {$out += Get-Random -Minimum 0 -Maximum 255}
[System.IO.File]::WriteAllBytes("myrandomfiletest", $out)
This uses an algorithm with a seed taken from the system clock, so don't use this for ANY serious cryptographic applications.

In addition, be wary of the performance degradation of Get-Random when increasing the size of the output file. More on this aspect here:

PowerShell random file generator too slow
Improve Powershell Performance to Generate a Random File
Share
Improve this answer
Follow
edited May 23, 2017 at 12:32
Community's user avatar
CommunityBot
111 silver badge
answered Sep 27, 2013 at 18:23
Gerrit's user avatar
Gerrit
85166 silver badges1111 bronze badges
Add a comment
16

I have been using Random Data File Creator and liking it, it creates binary files (i.e. not text files) filled with pseudo-random bits, it can quickly create very large files. To use it to create multiple small files you would need to script it, which would be very easy given it is command line.

Share
Improve this answer
Follow
edited Dec 25, 2015 at 11:57
mguassa's user avatar
mguassa
3,97122 gold badges1414 silver badges1919 bronze badges
answered Feb 5, 2010 at 19:20
David Waters's user avatar
David Waters
11.9k77 gold badges4141 silver badges7676 bronze badges
There are quite a few programs and cloud tools of this nature: raywoodcockslatest.wordpress.com/2021/08/21/dummy-files – 
Ray Woodcock
 May 17, 2022 at 14:08
Add a comment
8

Since you don't specify a language, I'll simply pick one at random. Here is a powershell script to do it:

$rootDir = 'C:\Temp\TestRandomFiles\'
$baseFile = $rootDir + "base.txt"
$desiredFileSize = 2*1KB
$fileCount = 50000
"start" | Out-File -Filepath $baseFile
While ($(Get-ChildItem -path $baseFile).Length -lt $desiredFileSize)
{
    $(Get-ChildItem -path $baseFile).Length | Out-File $baseFile -APPEND
}
for($i=1;$i -lt $fileCount;$i++)
{
    Copy-Item $baseFile "File$i.txt"
}
You'll have to change the variables to the parameters that you want of course.

Share
Improve this answer
Follow
answered Feb 10, 2009 at 19:47
EBGreen's user avatar
EBGreen
36.5k1212 gold badges6464 silver badges8484 bronze badges
1
oops...missed the random data requirement. Is that important? If so I can tweak it. – 
EBGreen
 Feb 10, 2009 at 19:48
1
If you are a PS whiz, I don't suppose you can do random data as I am keen to learn how this done! – 
Wil
 Jan 27, 2012 at 10:22 
I'm definitely not a whiz, but there are several ways. Basically you identify the data set that you want to randomize (say 0-9 and a-Z) then you randomly pick from that set to build the data for the file, then write it out to the file. If I have a chance later today, I'll alter the above code to use random data. – 
EBGreen
 Jan 27, 2012 at 15:12
@EBGreen thank You much! Best regards – 
Gennady G
 Nov 29, 2021 at 14:01
Add a comment
4

Instead of using Get-Random to generate the text as per user188737 & mguassa suggestions, I improved the speed by using GUIDs.

Function New-RandomFile {
    Param(
        $Path = '.', 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 
    (1..($FileSize/128)).foreach({-join ([guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-").SubString(1, 126) }) | set-content "$Path\$FileName"
}
This took 491 milliseconds to generate a 1mb file. Running:

New-RandomFile -FileSize 1mb
UPDATE:

I've updated my function to use a ScriptBlock, so you can replace the 'NewGuid()' method with anything you want.

In this scenario, I make 1kb chunks, since I know I'm never creating smaller files. This improved the speed of my function drastically!

Set-Content forces a NewLine at the end, which is why you need to remove 2 Characters each time you write to file. I've replaced it with [io.file]::WriteAllText() instead.

Function New-RandomFile_1kChunks {
    Param(
        $Path = (Resolve-Path '.').Path, 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 

    $Chunk = { [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-" }

    $Chunks = [math]::Ceiling($FileSize/1kb)

    [io.file]::WriteAllText("$Path\$FileName","$(-Join (1..($Chunks)).foreach({ $Chunk.Invoke() }))")

    Write-Warning "New-RandomFile: $Path\$FileName"

}
If you dont care that all chunks are random, you can simply Invoke() the generation of the 1kb chunk once.. this improves the speed drastically, but won't make the entire file random.

Function New-RandomFile_Fast {
    Param(
        $Path = (Resolve-Path '.').Path, 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 

    $Chunk = { [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-" }
    $Chunks = [math]::Ceiling($FileSize/1kb)
    $ChunkString = $Chunk.Invoke()

    [io.file]::WriteAllText("$Path\$FileName","$(-Join (1..($Chunks)).foreach({ $ChunkString }))")

    Write-Warning "New-RandomFile: $Path\$FileName"

}
Measure-Command all these changes to generate a 10mb file:

Executing New-RandomFile: 35.7688241 seconds.

Executing New-RandomFile_1kChunks: 25.1463777 seconds.

Executing New-RandomFile_Fast: 1.1626236 seconds.

Share
Improve this answer
Follow
edited Apr 3, 2017 at 23:04
answered Apr 1, 2017 at 2:39
Marc Kellerman's user avatar
Marc Kellerman
45622 silver badges1010 bronze badges
Add a comment
2

You'll have to create files in the normal way, and then populate them with randomized data, probably from a rand() function of some sort.

It really depends on your programming language. Windows itself certainly won't provide this capability.

There are a number of programming languages that could do this easily, however, including basic windows batch/CMD scripts. What language are you interested in using?

Share
Improve this answer
Follow
answered Feb 10, 2009 at 18:54
levand's user avatar
levand
8,39033 gold badges4040 silver badges5454 bronze badges
Add a comment
2

None of the answers here were cutting it for me, so here's a script which takes advantage of the Cryptography library to generate lots of random files.

This will generate files very quickly until your system's entropy is exhausted (on my PC this was about 4,000 files). After this it (and any other applications on your system that need cryptographic random numbers) will run very slowly. (In Linux terms, consider this script to use /dev/random instead of /dev/urandom)

$directory = (Get-Location).Path;
0..10000 | ForEach-Object {
    $size = 1023 * (Get-Random -Minimum 10 -Maximum 1536);
    $contents = [Byte[]]::new($size);

    $rng = [System.Security.Cryptography.RNGCryptoServiceProvider]::new();
    $rng.GetBytes($contents);

    $filename = "$directory\random$($_.ToString().PadLeft(5, '0')).txt"
    Write-Host $filename
    [System.IO.File]::WriteAllBytes($filename, $contents)
}
If you'd rather not deplete your system's entropy, replace the two $rng lines with these:

    $rng = [System.Random]::new();
    $rng.NextBytes($contents);
This will run much slower, but for large quantities of files (or larger files) it should be more reliable.

Share
Improve this answer
Follow
answered Apr 15, 2020 at 0:57
Joshua Walsh's user avatar
Joshua Walsh
1,88555 gold badges2525 silver badges5050 bronze badges
Add a comment
1

Yes, fsutil is great, but doesn't generate random data, just ASCII nulls.

I don't remember where I found this but searching on google these days I can still find it at: http://www.private-files.com/other/random.c.txt

I don't know how old this program is but at least as old as your question, probably somewhat older.

Anyway here's a program in C which creates files with a chi-squared test result of 0:

// ------------------------------------------------------------     
// Name: random.c  (program to create random files)
//     
// This "no-frills" program creates files with the following 
// characteristics: 
//
//    (1) Byte sequences are random (no predictability);
//    (2) Files produced are binary files; 
//    (3) File sizes are multiples of 256; 
//    (4) Files will have a chi-squared test result of 0
//        (see analyze.exe by Wenger for explanation)
//  
//              Programmer:  Scott Wenger
//                           Box 802
//                           Stevens Point, WI 54481
//                           panther@wctc.net
//
//       Note:  part of this code is from Knuth Volume II
// 
//  Enhancements and modifications of this program are left 
//  to the imagination and creativity of the programmer.
//  Check your compiler for required header files.  You may 
//  need to include the iostream header.
//
//  Random files are of potential use to cryptographers
//  for the purpose of encryption.  
//  
//  To analyze files produced by this program, see 
//  the analyze.exe program by Scott Wenger (found at
//  http://www.coredcs.com/sware.html)
// ------------------------------------------------------------


// This program works in the following way:
// The time is used to seed the random number generator.
// Using Knuth's algorithm, random numbers are generated
// in the range of 0 to 255 (corresponding to 256 ASCII chars.)
// When random numbers are generated they are marked as used and 
// are not re-used until all 256 ASCII values appear.  Characters 
// are written to disk and the process continues until the
// desired file size is reached.  Output is a random binary file
// called random.bin (placed in the root directory)
// The controlled filesize along with the placeholder feature 
// of this code forces a very high degree of randomness in 
// the output file. 

#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void init_mm();
void clear_array(); 
int  number_range(int minval, int maxval);
int  number_mm();

static int rgiState[2 + 55]; 
int place_holder[256];          // to keep track of numbers already generated

int main()
{
  mainprogram();
  return 0;
}

int mainprogram()
{
  int ch; 
  int c_used = 0;  // counter of chars in placeholder
  int done = 0; 
  int random;

  char buffer[2];

  long x;
  long byte_size = 0L;
  FILE *fp;

  clear_array();
  init_mm();  // seed random number generator

  // create a random file of length specified by user
  printf("\nrandom.exe originally by Scott Wenger");
  printf("\nThis program creates a random binary file.\n");
  printf("\nPlease specify length of random file to create (in megabytes): ");  

  scanf("%ld", &byte_size);

  while (byte_size > 1000 || byte_size <= 0 )
  {
    printf("\nWill not create files larger than a gigabyte! ");
    printf("\nPlease specify length of random file to create (in megabytes): ");
    flushall();
    scanf("%ld", &byte_size);
  }

  byte_size = byte_size * 1024 * 1024;

  if ( (fp = fopen("random.bin", "wb"))  == NULL) {
    fprintf(stderr, "\nOutput file (random.bin) could not be created.");      
    fflush(stdout);
    exit(1);
  }

  for (x = 0L; x < byte_size; x++) {

    if (c_used == 256) {
      clear_array();
      c_used = 0;
    }

    random = number_range(0, 255);    // use all ASCII values

    if ( *(place_holder + random) ) {  // already used, find another
      done = 0;
      while (!done) {
        random = number_range(0, 255);
        if ( *(place_holder + random) == 0) {
          *(place_holder + random) = 1;
          done = 1;
        }
      }         
    }
    else *(place_holder + random) = 1;  // use it and mark as used 

    c_used++;   // found next character so increment counter

    sprintf(buffer, "%c", random);  // convert ASCII value to char 
    ch = buffer[0];
    fputc(ch, fp); // write to file
  }

  fclose(fp);

  printf("\nDone. File \"random.bin\" was created (size: %ld bytes)", byte_size);
  printf("\nOutput file is in the root directory (c:\\random.bin)\n");
  return(0);
}

// ---------------------------------------------------------------------------------

void clear_array()
{
  register int x;
  for (x = 0; x < 256; x++) 
    *(place_holder + x) = 0;
}

// ---------------------------------------------------------------------------------

int number_mm()
{
    int *piState;
    int iState1;
    int iState2;
    int iRand;

    piState     = &rgiState[2];
    iState1     = piState[-2];
    iState2     = piState[-1];
    iRand       = ( piState[iState1] + piState[iState2] )
                & ( ( 1 << 30 ) - 1 );
    piState[iState1]    = iRand;

    if ( ++iState1 == 55 )  iState1 = 0;
    if ( ++iState2 == 55 )  iState2 = 0;

    piState[-2]     = iState1;
    piState[-1]     = iState2;

    return(iRand >> 6);
}

// ---------------------------------------------------------------------------------

//  Generate a random number.

int number_range( int minval, int maxval )
{
  int power, number;

  if ( ( maxval = maxval - minval + 1 ) <= 1 ) return (minval);

  for ( power = 2; power < maxval; power <<= 1 )
    ;
  while ( ( number = number_mm( ) & ( power - 1 ) ) >= maxval )
    ;
  return(minval + number);
}

// ---------------------------------------------------------------------------------

// Mitchell-Moore algorithm from Knuth Volume II. 

void init_mm( )
{
  int *piState;
  int iState;

  piState = &rgiState[2];
  piState[-2]   = 55 - 55;
  piState[-1]   = 55 - 24;
  piState[0]    = ( (int) time( NULL ) ) & ( ( 1 << 30 ) - 1 );
  piState[1]    = 1;

  for ( iState = 2; iState < 55; iState++ ) 
  {
    piState[iState] = ( piState[iState-1] + piState[iState-2] )
                      &  ( ( 1 << 30 ) - 1 );
  }
}

// -------------------- End -------------------------------------------------------
Share
Improve this answer
Follow
answered Aug 10, 2016 at 13:38
Rubenisme's user avatar
Rubenisme
78711 gold badge88 silver badges1515 bronze badges
Add a comment
1

So, i decided to add an accurate answer this time.

language is powershell. assumptions: filenames will be sequential and not random. file contents are to be cryptographically secure and unique. file location to be C:\temp\

#create a fixed size byte array for later use.  make it the required file size.
$bytearray = New-Object byte[] 2048

#create and start a stopwatch object to measure how long it all takes.
$stopwatch = [Diagnostics.Stopwatch]::StartNew()

#create a CSRNG object
$RNGObject = New-Object Security.Cryptography.RNGCryptoServiceProvider

# set up a loop to run 50000 times
0..49999 | Foreach-Object {

    # create a file stream handle with a name format 'filennnnn'
    $stream = New-Object System.IO.FileStream("c:\temp\file$("{0:D5}" -f $_)"), Create

    # and a stream writer handle
    $writer = New-Object System.IO.BinaryWriter($stream)

    # Fill our array from the CSRNG
    $RNGObject.GetNonZeroBytes($bytearray)

    # Append to the current file
    $writer.write($bytearray)

    # Close the stream
    $stream.close()

}
About
Products
For Teams
Search…
Join Stack Overflow to find the best answer to your technical question, help others answer theirs.

Home
PUBLIC
Questions
Tags
Users
Companies
COLLECTIVES
Explore Collectives
TEAMS
Stack Overflow for Teams – Start collaborating and sharing organizational knowledge. 
Generating Random Files in Windows
Asked 14 years, 3 months ago
Modified 5 months ago
Viewed 85k times
42

Does anyone have a way to generate files of random data in Windows? I would like to generate 50,000 small (2K) files as an example.

windows
Share
Improve this question
Follow
asked Feb 10, 2009 at 18:51
Jeff
2
Could you share with us whether you want text files or binary files? Could you also comment as to what programming languages you have access to (if any)? Do you have MS Office installed? Also, not very relevant, but what version of windows are you using? – 
user62572
 Feb 10, 2009 at 20:05
Add a comment
16 Answers
Sorted by:

Highest score (default)
34

You can run fsutil in a batch loop to create files of any size.

fsutil file createnew filename.extension 2000
Share
Improve this answer
Follow
answered Feb 10, 2009 at 19:01
Bogdan's user avatar
Bogdan
3,03511 gold badge2222 silver badges2020 bronze badges
I just found that utility. Didn't know it existed before. thebackroomtech.com/2009/01/16/… – 
beach
 Feb 10, 2009 at 19:04
41
However, it doesn't create random data. Just blank files. – 
beach
 Feb 10, 2009 at 19:07
And it seems to require admin permissions. Going with the powershell. – 
Mathias Mamsch
 Oct 25, 2017 at 7:21
Add a comment
21

One-liner in Powershell:

$out = new-object byte[] 1048576; (new-object Random).NextBytes($out); [IO.File]::WriteAllBytes('d:\file.bin', $out)
This is lightning fast, compared to @user188737 solution.

Share
Improve this answer
Follow
answered Sep 26, 2017 at 7:07
gwiazdorrr's user avatar
gwiazdorrr
6,16122 gold badges2727 silver badges3636 bronze badges
1
Every single file that this one liner creates is identical. Is there any way to make the content of each file different – 
Dhiwakar Ravikumar
 Apr 15, 2018 at 4:47
3
Are you sure this is the case? I tried it on my system, ran it 3 times, got 3 distinct files. The constructor for the Random type is by default based on the system time, so perhaps if you run this multiple times in very quick succession, you might get identical files. You could avoid this by creating a single Random object and then reusing it for each consecutive file: $rnd = New-Object Random; once at the top, and then $rnd.NextBytes instead of (New-Object Random).NextBytes when generating the file. – 
Jonathan Gilbert
 May 29, 2018 at 16:19
Add a comment
18

You can use PowerShell to generate cheap random data for your files:

[Byte[]] $out = @()
0..2047 | % {$out += Get-Random -Minimum 0 -Maximum 255}
[System.IO.File]::WriteAllBytes("myrandomfiletest", $out)
This uses an algorithm with a seed taken from the system clock, so don't use this for ANY serious cryptographic applications.

In addition, be wary of the performance degradation of Get-Random when increasing the size of the output file. More on this aspect here:

PowerShell random file generator too slow
Improve Powershell Performance to Generate a Random File
Share
Improve this answer
Follow
edited May 23, 2017 at 12:32
Community's user avatar
CommunityBot
111 silver badge
answered Sep 27, 2013 at 18:23
Gerrit's user avatar
Gerrit
85166 silver badges1111 bronze badges
Add a comment
16

I have been using Random Data File Creator and liking it, it creates binary files (i.e. not text files) filled with pseudo-random bits, it can quickly create very large files. To use it to create multiple small files you would need to script it, which would be very easy given it is command line.

Share
Improve this answer
Follow
edited Dec 25, 2015 at 11:57
mguassa's user avatar
mguassa
3,97122 gold badges1414 silver badges1919 bronze badges
answered Feb 5, 2010 at 19:20
David Waters's user avatar
David Waters
11.9k77 gold badges4141 silver badges7676 bronze badges
There are quite a few programs and cloud tools of this nature: raywoodcockslatest.wordpress.com/2021/08/21/dummy-files – 
Ray Woodcock
 May 17, 2022 at 14:08
Add a comment
8

Since you don't specify a language, I'll simply pick one at random. Here is a powershell script to do it:

$rootDir = 'C:\Temp\TestRandomFiles\'
$baseFile = $rootDir + "base.txt"
$desiredFileSize = 2*1KB
$fileCount = 50000
"start" | Out-File -Filepath $baseFile
While ($(Get-ChildItem -path $baseFile).Length -lt $desiredFileSize)
{
    $(Get-ChildItem -path $baseFile).Length | Out-File $baseFile -APPEND
}
for($i=1;$i -lt $fileCount;$i++)
{
    Copy-Item $baseFile "File$i.txt"
}
You'll have to change the variables to the parameters that you want of course.

Share
Improve this answer
Follow
answered Feb 10, 2009 at 19:47
EBGreen's user avatar
EBGreen
36.5k1212 gold badges6464 silver badges8484 bronze badges
1
oops...missed the random data requirement. Is that important? If so I can tweak it. – 
EBGreen
 Feb 10, 2009 at 19:48
1
If you are a PS whiz, I don't suppose you can do random data as I am keen to learn how this done! – 
Wil
 Jan 27, 2012 at 10:22 
I'm definitely not a whiz, but there are several ways. Basically you identify the data set that you want to randomize (say 0-9 and a-Z) then you randomly pick from that set to build the data for the file, then write it out to the file. If I have a chance later today, I'll alter the above code to use random data. – 
EBGreen
 Jan 27, 2012 at 15:12
@EBGreen thank You much! Best regards – 
Gennady G
 Nov 29, 2021 at 14:01
Add a comment
4

Instead of using Get-Random to generate the text as per user188737 & mguassa suggestions, I improved the speed by using GUIDs.

Function New-RandomFile {
    Param(
        $Path = '.', 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 
    (1..($FileSize/128)).foreach({-join ([guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-").SubString(1, 126) }) | set-content "$Path\$FileName"
}
This took 491 milliseconds to generate a 1mb file. Running:

New-RandomFile -FileSize 1mb
UPDATE:

I've updated my function to use a ScriptBlock, so you can replace the 'NewGuid()' method with anything you want.

In this scenario, I make 1kb chunks, since I know I'm never creating smaller files. This improved the speed of my function drastically!

Set-Content forces a NewLine at the end, which is why you need to remove 2 Characters each time you write to file. I've replaced it with [io.file]::WriteAllText() instead.

Function New-RandomFile_1kChunks {
    Param(
        $Path = (Resolve-Path '.').Path, 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 

    $Chunk = { [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-" }

    $Chunks = [math]::Ceiling($FileSize/1kb)

    [io.file]::WriteAllText("$Path\$FileName","$(-Join (1..($Chunks)).foreach({ $Chunk.Invoke() }))")

    Write-Warning "New-RandomFile: $Path\$FileName"

}
If you dont care that all chunks are random, you can simply Invoke() the generation of the 1kb chunk once.. this improves the speed drastically, but won't make the entire file random.

Function New-RandomFile_Fast {
    Param(
        $Path = (Resolve-Path '.').Path, 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 

    $Chunk = { [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-" }
    $Chunks = [math]::Ceiling($FileSize/1kb)
    $ChunkString = $Chunk.Invoke()

    [io.file]::WriteAllText("$Path\$FileName","$(-Join (1..($Chunks)).foreach({ $ChunkString }))")

    Write-Warning "New-RandomFile: $Path\$FileName"

}
Measure-Command all these changes to generate a 10mb file:

Executing New-RandomFile: 35.7688241 seconds.

Executing New-RandomFile_1kChunks: 25.1463777 seconds.

Executing New-RandomFile_Fast: 1.1626236 seconds.

Share
Improve this answer
Follow
edited Apr 3, 2017 at 23:04
answered Apr 1, 2017 at 2:39
Marc Kellerman's user avatar
Marc Kellerman
45622 silver badges1010 bronze badges
Add a comment
2

You'll have to create files in the normal way, and then populate them with randomized data, probably from a rand() function of some sort.

It really depends on your programming language. Windows itself certainly won't provide this capability.

There are a number of programming languages that could do this easily, however, including basic windows batch/CMD scripts. What language are you interested in using?

Share
Improve this answer
Follow
answered Feb 10, 2009 at 18:54
levand's user avatar
levand
8,39033 gold badges4040 silver badges5454 bronze badges
Add a comment
2

None of the answers here were cutting it for me, so here's a script which takes advantage of the Cryptography library to generate lots of random files.

This will generate files very quickly until your system's entropy is exhausted (on my PC this was about 4,000 files). After this it (and any other applications on your system that need cryptographic random numbers) will run very slowly. (In Linux terms, consider this script to use /dev/random instead of /dev/urandom)

$directory = (Get-Location).Path;
0..10000 | ForEach-Object {
    $size = 1023 * (Get-Random -Minimum 10 -Maximum 1536);
    $contents = [Byte[]]::new($size);

    $rng = [System.Security.Cryptography.RNGCryptoServiceProvider]::new();
    $rng.GetBytes($contents);

    $filename = "$directory\random$($_.ToString().PadLeft(5, '0')).txt"
    Write-Host $filename
    [System.IO.File]::WriteAllBytes($filename, $contents)
}
If you'd rather not deplete your system's entropy, replace the two $rng lines with these:

    $rng = [System.Random]::new();
    $rng.NextBytes($contents);
This will run much slower, but for large quantities of files (or larger files) it should be more reliable.

Share
Improve this answer
Follow
answered Apr 15, 2020 at 0:57
Joshua Walsh's user avatar
Joshua Walsh
1,88555 gold badges2525 silver badges5050 bronze badges
Add a comment
1

Yes, fsutil is great, but doesn't generate random data, just ASCII nulls.

I don't remember where I found this but searching on google these days I can still find it at: http://www.private-files.com/other/random.c.txt

I don't know how old this program is but at least as old as your question, probably somewhat older.

Anyway here's a program in C which creates files with a chi-squared test result of 0:

// ------------------------------------------------------------     
// Name: random.c  (program to create random files)
//     
// This "no-frills" program creates files with the following 
// characteristics: 
//
//    (1) Byte sequences are random (no predictability);
//    (2) Files produced are binary files; 
//    (3) File sizes are multiples of 256; 
//    (4) Files will have a chi-squared test result of 0
//        (see analyze.exe by Wenger for explanation)
//  
//              Programmer:  Scott Wenger
//                           Box 802
//                           Stevens Point, WI 54481
//                           panther@wctc.net
//
//       Note:  part of this code is from Knuth Volume II
// 
//  Enhancements and modifications of this program are left 
//  to the imagination and creativity of the programmer.
//  Check your compiler for required header files.  You may 
//  need to include the iostream header.
//
//  Random files are of potential use to cryptographers
//  for the purpose of encryption.  
//  
//  To analyze files produced by this program, see 
//  the analyze.exe program by Scott Wenger (found at
//  http://www.coredcs.com/sware.html)
// ------------------------------------------------------------


// This program works in the following way:
// The time is used to seed the random number generator.
// Using Knuth's algorithm, random numbers are generated
// in the range of 0 to 255 (corresponding to 256 ASCII chars.)
// When random numbers are generated they are marked as used and 
// are not re-used until all 256 ASCII values appear.  Characters 
// are written to disk and the process continues until the
// desired file size is reached.  Output is a random binary file
// called random.bin (placed in the root directory)
// The controlled filesize along with the placeholder feature 
// of this code forces a very high degree of randomness in 
// the output file. 

#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void init_mm();
void clear_array(); 
int  number_range(int minval, int maxval);
int  number_mm();

static int rgiState[2 + 55]; 
int place_holder[256];          // to keep track of numbers already generated

int main()
{
  mainprogram();
  return 0;
}

int mainprogram()
{
  int ch; 
  int c_used = 0;  // counter of chars in placeholder
  int done = 0; 
  int random;

  char buffer[2];

  long x;
  long byte_size = 0L;
  FILE *fp;

  clear_array();
  init_mm();  // seed random number generator

  // create a random file of length specified by user
  printf("\nrandom.exe originally by Scott Wenger");
  printf("\nThis program creates a random binary file.\n");
  printf("\nPlease specify length of random file to create (in megabytes): ");  

  scanf("%ld", &byte_size);

  while (byte_size > 1000 || byte_size <= 0 )
  {
    printf("\nWill not create files larger than a gigabyte! ");
    printf("\nPlease specify length of random file to create (in megabytes): ");
    flushall();
    scanf("%ld", &byte_size);
  }

  byte_size = byte_size * 1024 * 1024;

  if ( (fp = fopen("random.bin", "wb"))  == NULL) {
    fprintf(stderr, "\nOutput file (random.bin) could not be created.");      
    fflush(stdout);
    exit(1);
  }

  for (x = 0L; x < byte_size; x++) {

    if (c_used == 256) {
      clear_array();
      c_used = 0;
    }

    random = number_range(0, 255);    // use all ASCII values

    if ( *(place_holder + random) ) {  // already used, find another
      done = 0;
      while (!done) {
        random = number_range(0, 255);
        if ( *(place_holder + random) == 0) {
          *(place_holder + random) = 1;
          done = 1;
        }
      }         
    }
    else *(place_holder + random) = 1;  // use it and mark as used 

    c_used++;   // found next character so increment counter

    sprintf(buffer, "%c", random);  // convert ASCII value to char 
    ch = buffer[0];
    fputc(ch, fp); // write to file
  }

  fclose(fp);

  printf("\nDone. File \"random.bin\" was created (size: %ld bytes)", byte_size);
  printf("\nOutput file is in the root directory (c:\\random.bin)\n");
  return(0);
}

// ---------------------------------------------------------------------------------

void clear_array()
{
  register int x;
  for (x = 0; x < 256; x++) 
    *(place_holder + x) = 0;
}

// ---------------------------------------------------------------------------------

int number_mm()
{
    int *piState;
    int iState1;
    int iState2;
    int iRand;

    piState     = &rgiState[2];
    iState1     = piState[-2];
    iState2     = piState[-1];
    iRand       = ( piState[iState1] + piState[iState2] )
                & ( ( 1 << 30 ) - 1 );
    piState[iState1]    = iRand;

    if ( ++iState1 == 55 )  iState1 = 0;
    if ( ++iState2 == 55 )  iState2 = 0;

    piState[-2]     = iState1;
    piState[-1]     = iState2;

    return(iRand >> 6);
}

// ---------------------------------------------------------------------------------

//  Generate a random number.

int number_range( int minval, int maxval )
{
  int power, number;

  if ( ( maxval = maxval - minval + 1 ) <= 1 ) return (minval);

  for ( power = 2; power < maxval; power <<= 1 )
    ;
  while ( ( number = number_mm( ) & ( power - 1 ) ) >= maxval )
    ;
  return(minval + number);
}

// ---------------------------------------------------------------------------------

// Mitchell-Moore algorithm from Knuth Volume II. 

void init_mm( )
{
  int *piState;
  int iState;

  piState = &rgiState[2];
  piState[-2]   = 55 - 55;
  piState[-1]   = 55 - 24;
  piState[0]    = ( (int) time( NULL ) ) & ( ( 1 << 30 ) - 1 );
  piState[1]    = 1;

  for ( iState = 2; iState < 55; iState++ ) 
  {
    piState[iState] = ( piState[iState-1] + piState[iState-2] )
                      &  ( ( 1 << 30 ) - 1 );
  }
}

// -------------------- End -------------------------------------------------------
Share
Improve this answer
Follow
answered Aug 10, 2016 at 13:38
Rubenisme's user avatar
Rubenisme
78711 gold badge88 silver badges1515 bronze badges
Add a comment
1

So, i decided to add an accurate answer this time.

language is powershell. assumptions: filenames will be sequential and not random. file contents are to be cryptographically secure and unique. file location to be C:\temp\

#create a fixed size byte array for later use.  make it the required file size.
$bytearray = New-Object byte[] 2048

#create and start a stopwatch object to measure how long it all takes.
$stopwatch = [Diagnostics.Stopwatch]::StartNew()

#create a CSRNG object
$RNGObject = New-Object Security.Cryptography.RNGCryptoServiceProvider

# set up a loop to run 50000 times
0..49999 | Foreach-Object {

    # create a file stream handle with a name format 'filennnnn'
    $stream = New-Object System.IO.FileStream("c:\temp\file$("{0:D5}" -f $_)"), Create

    # and a stream writer handle
    $writer = New-Object System.IO.BinaryWriter($stream)

    # Fill our array from the CSRNG
    $RNGObject.GetNonZeroBytes($bytearray)

    # Append to the current file
    $writer.write($bytearray)

    # Close the stream
    $stream.close()

}
About
Products
For Teams
Search…
Join Stack Overflow to find the best answer to your technical question, help others answer theirs.

Home
PUBLIC
Questions
Tags
Users
Companies
COLLECTIVES
Explore Collectives
TEAMS
Stack Overflow for Teams – Start collaborating and sharing organizational knowledge. 
Generating Random Files in Windows
Asked 14 years, 3 months ago
Modified 5 months ago
Viewed 85k times
42

Does anyone have a way to generate files of random data in Windows? I would like to generate 50,000 small (2K) files as an example.

windows
Share
Improve this question
Follow
asked Feb 10, 2009 at 18:51
Jeff
2
Could you share with us whether you want text files or binary files? Could you also comment as to what programming languages you have access to (if any)? Do you have MS Office installed? Also, not very relevant, but what version of windows are you using? – 
user62572
 Feb 10, 2009 at 20:05
Add a comment
16 Answers
Sorted by:

Highest score (default)
34

You can run fsutil in a batch loop to create files of any size.

fsutil file createnew filename.extension 2000
Share
Improve this answer
Follow
answered Feb 10, 2009 at 19:01
Bogdan's user avatar
Bogdan
3,03511 gold badge2222 silver badges2020 bronze badges
I just found that utility. Didn't know it existed before. thebackroomtech.com/2009/01/16/… – 
beach
 Feb 10, 2009 at 19:04
41
However, it doesn't create random data. Just blank files. – 
beach
 Feb 10, 2009 at 19:07
And it seems to require admin permissions. Going with the powershell. – 
Mathias Mamsch
 Oct 25, 2017 at 7:21
Add a comment
21

One-liner in Powershell:

$out = new-object byte[] 1048576; (new-object Random).NextBytes($out); [IO.File]::WriteAllBytes('d:\file.bin', $out)
This is lightning fast, compared to @user188737 solution.

Share
Improve this answer
Follow
answered Sep 26, 2017 at 7:07
gwiazdorrr's user avatar
gwiazdorrr
6,16122 gold badges2727 silver badges3636 bronze badges
1
Every single file that this one liner creates is identical. Is there any way to make the content of each file different – 
Dhiwakar Ravikumar
 Apr 15, 2018 at 4:47
3
Are you sure this is the case? I tried it on my system, ran it 3 times, got 3 distinct files. The constructor for the Random type is by default based on the system time, so perhaps if you run this multiple times in very quick succession, you might get identical files. You could avoid this by creating a single Random object and then reusing it for each consecutive file: $rnd = New-Object Random; once at the top, and then $rnd.NextBytes instead of (New-Object Random).NextBytes when generating the file. – 
Jonathan Gilbert
 May 29, 2018 at 16:19
Add a comment
18

You can use PowerShell to generate cheap random data for your files:

[Byte[]] $out = @()
0..2047 | % {$out += Get-Random -Minimum 0 -Maximum 255}
[System.IO.File]::WriteAllBytes("myrandomfiletest", $out)
This uses an algorithm with a seed taken from the system clock, so don't use this for ANY serious cryptographic applications.

In addition, be wary of the performance degradation of Get-Random when increasing the size of the output file. More on this aspect here:

PowerShell random file generator too slow
Improve Powershell Performance to Generate a Random File
Share
Improve this answer
Follow
edited May 23, 2017 at 12:32
Community's user avatar
CommunityBot
111 silver badge
answered Sep 27, 2013 at 18:23
Gerrit's user avatar
Gerrit
85166 silver badges1111 bronze badges
Add a comment
16

I have been using Random Data File Creator and liking it, it creates binary files (i.e. not text files) filled with pseudo-random bits, it can quickly create very large files. To use it to create multiple small files you would need to script it, which would be very easy given it is command line.

Share
Improve this answer
Follow
edited Dec 25, 2015 at 11:57
mguassa's user avatar
mguassa
3,97122 gold badges1414 silver badges1919 bronze badges
answered Feb 5, 2010 at 19:20
David Waters's user avatar
David Waters
11.9k77 gold badges4141 silver badges7676 bronze badges
There are quite a few programs and cloud tools of this nature: raywoodcockslatest.wordpress.com/2021/08/21/dummy-files – 
Ray Woodcock
 May 17, 2022 at 14:08
Add a comment
8

Since you don't specify a language, I'll simply pick one at random. Here is a powershell script to do it:

$rootDir = 'C:\Temp\TestRandomFiles\'
$baseFile = $rootDir + "base.txt"
$desiredFileSize = 2*1KB
$fileCount = 50000
"start" | Out-File -Filepath $baseFile
While ($(Get-ChildItem -path $baseFile).Length -lt $desiredFileSize)
{
    $(Get-ChildItem -path $baseFile).Length | Out-File $baseFile -APPEND
}
for($i=1;$i -lt $fileCount;$i++)
{
    Copy-Item $baseFile "File$i.txt"
}
You'll have to change the variables to the parameters that you want of course.

Share
Improve this answer
Follow
answered Feb 10, 2009 at 19:47
EBGreen's user avatar
EBGreen
36.5k1212 gold badges6464 silver badges8484 bronze badges
1
oops...missed the random data requirement. Is that important? If so I can tweak it. – 
EBGreen
 Feb 10, 2009 at 19:48
1
If you are a PS whiz, I don't suppose you can do random data as I am keen to learn how this done! – 
Wil
 Jan 27, 2012 at 10:22 
I'm definitely not a whiz, but there are several ways. Basically you identify the data set that you want to randomize (say 0-9 and a-Z) then you randomly pick from that set to build the data for the file, then write it out to the file. If I have a chance later today, I'll alter the above code to use random data. – 
EBGreen
 Jan 27, 2012 at 15:12
@EBGreen thank You much! Best regards – 
Gennady G
 Nov 29, 2021 at 14:01
Add a comment
4

Instead of using Get-Random to generate the text as per user188737 & mguassa suggestions, I improved the speed by using GUIDs.

Function New-RandomFile {
    Param(
        $Path = '.', 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 
    (1..($FileSize/128)).foreach({-join ([guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-").SubString(1, 126) }) | set-content "$Path\$FileName"
}
This took 491 milliseconds to generate a 1mb file. Running:

New-RandomFile -FileSize 1mb
UPDATE:

I've updated my function to use a ScriptBlock, so you can replace the 'NewGuid()' method with anything you want.

In this scenario, I make 1kb chunks, since I know I'm never creating smaller files. This improved the speed of my function drastically!

Set-Content forces a NewLine at the end, which is why you need to remove 2 Characters each time you write to file. I've replaced it with [io.file]::WriteAllText() instead.

Function New-RandomFile_1kChunks {
    Param(
        $Path = (Resolve-Path '.').Path, 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 

    $Chunk = { [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-" }

    $Chunks = [math]::Ceiling($FileSize/1kb)

    [io.file]::WriteAllText("$Path\$FileName","$(-Join (1..($Chunks)).foreach({ $Chunk.Invoke() }))")

    Write-Warning "New-RandomFile: $Path\$FileName"

}
If you dont care that all chunks are random, you can simply Invoke() the generation of the 1kb chunk once.. this improves the speed drastically, but won't make the entire file random.

Function New-RandomFile_Fast {
    Param(
        $Path = (Resolve-Path '.').Path, 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 

    $Chunk = { [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-" }
    $Chunks = [math]::Ceiling($FileSize/1kb)
    $ChunkString = $Chunk.Invoke()

    [io.file]::WriteAllText("$Path\$FileName","$(-Join (1..($Chunks)).foreach({ $ChunkString }))")

    Write-Warning "New-RandomFile: $Path\$FileName"

}
Measure-Command all these changes to generate a 10mb file:

Executing New-RandomFile: 35.7688241 seconds.

Executing New-RandomFile_1kChunks: 25.1463777 seconds.

Executing New-RandomFile_Fast: 1.1626236 seconds.

Share
Improve this answer
Follow
edited Apr 3, 2017 at 23:04
answered Apr 1, 2017 at 2:39
Marc Kellerman's user avatar
Marc Kellerman
45622 silver badges1010 bronze badges
Add a comment
2

You'll have to create files in the normal way, and then populate them with randomized data, probably from a rand() function of some sort.

It really depends on your programming language. Windows itself certainly won't provide this capability.

There are a number of programming languages that could do this easily, however, including basic windows batch/CMD scripts. What language are you interested in using?

Share
Improve this answer
Follow
answered Feb 10, 2009 at 18:54
levand's user avatar
levand
8,39033 gold badges4040 silver badges5454 bronze badges
Add a comment
2

None of the answers here were cutting it for me, so here's a script which takes advantage of the Cryptography library to generate lots of random files.

This will generate files very quickly until your system's entropy is exhausted (on my PC this was about 4,000 files). After this it (and any other applications on your system that need cryptographic random numbers) will run very slowly. (In Linux terms, consider this script to use /dev/random instead of /dev/urandom)

$directory = (Get-Location).Path;
0..10000 | ForEach-Object {
    $size = 1023 * (Get-Random -Minimum 10 -Maximum 1536);
    $contents = [Byte[]]::new($size);

    $rng = [System.Security.Cryptography.RNGCryptoServiceProvider]::new();
    $rng.GetBytes($contents);

    $filename = "$directory\random$($_.ToString().PadLeft(5, '0')).txt"
    Write-Host $filename
    [System.IO.File]::WriteAllBytes($filename, $contents)
}
If you'd rather not deplete your system's entropy, replace the two $rng lines with these:

    $rng = [System.Random]::new();
    $rng.NextBytes($contents);
This will run much slower, but for large quantities of files (or larger files) it should be more reliable.

Share
Improve this answer
Follow
answered Apr 15, 2020 at 0:57
Joshua Walsh's user avatar
Joshua Walsh
1,88555 gold badges2525 silver badges5050 bronze badges
Add a comment
1

Yes, fsutil is great, but doesn't generate random data, just ASCII nulls.

I don't remember where I found this but searching on google these days I can still find it at: http://www.private-files.com/other/random.c.txt

I don't know how old this program is but at least as old as your question, probably somewhat older.

Anyway here's a program in C which creates files with a chi-squared test result of 0:

// ------------------------------------------------------------     
// Name: random.c  (program to create random files)
//     
// This "no-frills" program creates files with the following 
// characteristics: 
//
//    (1) Byte sequences are random (no predictability);
//    (2) Files produced are binary files; 
//    (3) File sizes are multiples of 256; 
//    (4) Files will have a chi-squared test result of 0
//        (see analyze.exe by Wenger for explanation)
//  
//              Programmer:  Scott Wenger
//                           Box 802
//                           Stevens Point, WI 54481
//                           panther@wctc.net
//
//       Note:  part of this code is from Knuth Volume II
// 
//  Enhancements and modifications of this program are left 
//  to the imagination and creativity of the programmer.
//  Check your compiler for required header files.  You may 
//  need to include the iostream header.
//
//  Random files are of potential use to cryptographers
//  for the purpose of encryption.  
//  
//  To analyze files produced by this program, see 
//  the analyze.exe program by Scott Wenger (found at
//  http://www.coredcs.com/sware.html)
// ------------------------------------------------------------


// This program works in the following way:
// The time is used to seed the random number generator.
// Using Knuth's algorithm, random numbers are generated
// in the range of 0 to 255 (corresponding to 256 ASCII chars.)
// When random numbers are generated they are marked as used and 
// are not re-used until all 256 ASCII values appear.  Characters 
// are written to disk and the process continues until the
// desired file size is reached.  Output is a random binary file
// called random.bin (placed in the root directory)
// The controlled filesize along with the placeholder feature 
// of this code forces a very high degree of randomness in 
// the output file. 

#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void init_mm();
void clear_array(); 
int  number_range(int minval, int maxval);
int  number_mm();

static int rgiState[2 + 55]; 
int place_holder[256];          // to keep track of numbers already generated

int main()
{
  mainprogram();
  return 0;
}

int mainprogram()
{
  int ch; 
  int c_used = 0;  // counter of chars in placeholder
  int done = 0; 
  int random;

  char buffer[2];

  long x;
  long byte_size = 0L;
  FILE *fp;

  clear_array();
  init_mm();  // seed random number generator

  // create a random file of length specified by user
  printf("\nrandom.exe originally by Scott Wenger");
  printf("\nThis program creates a random binary file.\n");
  printf("\nPlease specify length of random file to create (in megabytes): ");  

  scanf("%ld", &byte_size);

  while (byte_size > 1000 || byte_size <= 0 )
  {
    printf("\nWill not create files larger than a gigabyte! ");
    printf("\nPlease specify length of random file to create (in megabytes): ");
    flushall();
    scanf("%ld", &byte_size);
  }

  byte_size = byte_size * 1024 * 1024;

  if ( (fp = fopen("random.bin", "wb"))  == NULL) {
    fprintf(stderr, "\nOutput file (random.bin) could not be created.");      
    fflush(stdout);
    exit(1);
  }

  for (x = 0L; x < byte_size; x++) {

    if (c_used == 256) {
      clear_array();
      c_used = 0;
    }

    random = number_range(0, 255);    // use all ASCII values

    if ( *(place_holder + random) ) {  // already used, find another
      done = 0;
      while (!done) {
        random = number_range(0, 255);
        if ( *(place_holder + random) == 0) {
          *(place_holder + random) = 1;
          done = 1;
        }
      }         
    }
    else *(place_holder + random) = 1;  // use it and mark as used 

    c_used++;   // found next character so increment counter

    sprintf(buffer, "%c", random);  // convert ASCII value to char 
    ch = buffer[0];
    fputc(ch, fp); // write to file
  }

  fclose(fp);

  printf("\nDone. File \"random.bin\" was created (size: %ld bytes)", byte_size);
  printf("\nOutput file is in the root directory (c:\\random.bin)\n");
  return(0);
}

// ---------------------------------------------------------------------------------

void clear_array()
{
  register int x;
  for (x = 0; x < 256; x++) 
    *(place_holder + x) = 0;
}

// ---------------------------------------------------------------------------------

int number_mm()
{
    int *piState;
    int iState1;
    int iState2;
    int iRand;

    piState     = &rgiState[2];
    iState1     = piState[-2];
    iState2     = piState[-1];
    iRand       = ( piState[iState1] + piState[iState2] )
                & ( ( 1 << 30 ) - 1 );
    piState[iState1]    = iRand;

    if ( ++iState1 == 55 )  iState1 = 0;
    if ( ++iState2 == 55 )  iState2 = 0;

    piState[-2]     = iState1;
    piState[-1]     = iState2;

    return(iRand >> 6);
}

// ---------------------------------------------------------------------------------

//  Generate a random number.

int number_range( int minval, int maxval )
{
  int power, number;

  if ( ( maxval = maxval - minval + 1 ) <= 1 ) return (minval);

  for ( power = 2; power < maxval; power <<= 1 )
    ;
  while ( ( number = number_mm( ) & ( power - 1 ) ) >= maxval )
    ;
  return(minval + number);
}

// ---------------------------------------------------------------------------------

// Mitchell-Moore algorithm from Knuth Volume II. 

void init_mm( )
{
  int *piState;
  int iState;

  piState = &rgiState[2];
  piState[-2]   = 55 - 55;
  piState[-1]   = 55 - 24;
  piState[0]    = ( (int) time( NULL ) ) & ( ( 1 << 30 ) - 1 );
  piState[1]    = 1;

  for ( iState = 2; iState < 55; iState++ ) 
  {
    piState[iState] = ( piState[iState-1] + piState[iState-2] )
                      &  ( ( 1 << 30 ) - 1 );
  }
}

// -------------------- End -------------------------------------------------------
Share
Improve this answer
Follow
answered Aug 10, 2016 at 13:38
Rubenisme's user avatar
Rubenisme
78711 gold badge88 silver badges1515 bronze badges
Add a comment
1

So, i decided to add an accurate answer this time.

language is powershell. assumptions: filenames will be sequential and not random. file contents are to be cryptographically secure and unique. file location to be C:\temp\

#create a fixed size byte array for later use.  make it the required file size.
$bytearray = New-Object byte[] 2048

#create and start a stopwatch object to measure how long it all takes.
$stopwatch = [Diagnostics.Stopwatch]::StartNew()

#create a CSRNG object
$RNGObject = New-Object Security.Cryptography.RNGCryptoServiceProvider

# set up a loop to run 50000 times
0..49999 | Foreach-Object {

    # create a file stream handle with a name format 'filennnnn'
    $stream = New-Object System.IO.FileStream("c:\temp\file$("{0:D5}" -f $_)"), Create

    # and a stream writer handle
    $writer = New-Object System.IO.BinaryWriter($stream)

    # Fill our array from the CSRNG
    $RNGObject.GetNonZeroBytes($bytearray)

    # Append to the current file
    $writer.write($bytearray)

    # Close the stream
    $stream.close()

}
About
Products
For Teams
Search…
Join Stack Overflow to find the best answer to your technical question, help others answer theirs.

Home
PUBLIC
Questions
Tags
Users
Companies
COLLECTIVES
Explore Collectives
TEAMS
Stack Overflow for Teams – Start collaborating and sharing organizational knowledge. 
Generating Random Files in Windows
Asked 14 years, 3 months ago
Modified 5 months ago
Viewed 85k times
42

Does anyone have a way to generate files of random data in Windows? I would like to generate 50,000 small (2K) files as an example.

windows
Share
Improve this question
Follow
asked Feb 10, 2009 at 18:51
Jeff
2
Could you share with us whether you want text files or binary files? Could you also comment as to what programming languages you have access to (if any)? Do you have MS Office installed? Also, not very relevant, but what version of windows are you using? – 
user62572
 Feb 10, 2009 at 20:05
Add a comment
16 Answers
Sorted by:

Highest score (default)
34

You can run fsutil in a batch loop to create files of any size.

fsutil file createnew filename.extension 2000
Share
Improve this answer
Follow
answered Feb 10, 2009 at 19:01
Bogdan's user avatar
Bogdan
3,03511 gold badge2222 silver badges2020 bronze badges
I just found that utility. Didn't know it existed before. thebackroomtech.com/2009/01/16/… – 
beach
 Feb 10, 2009 at 19:04
41
However, it doesn't create random data. Just blank files. – 
beach
 Feb 10, 2009 at 19:07
And it seems to require admin permissions. Going with the powershell. – 
Mathias Mamsch
 Oct 25, 2017 at 7:21
Add a comment
21

One-liner in Powershell:

$out = new-object byte[] 1048576; (new-object Random).NextBytes($out); [IO.File]::WriteAllBytes('d:\file.bin', $out)
This is lightning fast, compared to @user188737 solution.

Share
Improve this answer
Follow
answered Sep 26, 2017 at 7:07
gwiazdorrr's user avatar
gwiazdorrr
6,16122 gold badges2727 silver badges3636 bronze badges
1
Every single file that this one liner creates is identical. Is there any way to make the content of each file different – 
Dhiwakar Ravikumar
 Apr 15, 2018 at 4:47
3
Are you sure this is the case? I tried it on my system, ran it 3 times, got 3 distinct files. The constructor for the Random type is by default based on the system time, so perhaps if you run this multiple times in very quick succession, you might get identical files. You could avoid this by creating a single Random object and then reusing it for each consecutive file: $rnd = New-Object Random; once at the top, and then $rnd.NextBytes instead of (New-Object Random).NextBytes when generating the file. – 
Jonathan Gilbert
 May 29, 2018 at 16:19
Add a comment
18

You can use PowerShell to generate cheap random data for your files:

[Byte[]] $out = @()
0..2047 | % {$out += Get-Random -Minimum 0 -Maximum 255}
[System.IO.File]::WriteAllBytes("myrandomfiletest", $out)
This uses an algorithm with a seed taken from the system clock, so don't use this for ANY serious cryptographic applications.

In addition, be wary of the performance degradation of Get-Random when increasing the size of the output file. More on this aspect here:

PowerShell random file generator too slow
Improve Powershell Performance to Generate a Random File
Share
Improve this answer
Follow
edited May 23, 2017 at 12:32
Community's user avatar
CommunityBot
111 silver badge
answered Sep 27, 2013 at 18:23
Gerrit's user avatar
Gerrit
85166 silver badges1111 bronze badges
Add a comment
16

I have been using Random Data File Creator and liking it, it creates binary files (i.e. not text files) filled with pseudo-random bits, it can quickly create very large files. To use it to create multiple small files you would need to script it, which would be very easy given it is command line.

Share
Improve this answer
Follow
edited Dec 25, 2015 at 11:57
mguassa's user avatar
mguassa
3,97122 gold badges1414 silver badges1919 bronze badges
answered Feb 5, 2010 at 19:20
David Waters's user avatar
David Waters
11.9k77 gold badges4141 silver badges7676 bronze badges
There are quite a few programs and cloud tools of this nature: raywoodcockslatest.wordpress.com/2021/08/21/dummy-files – 
Ray Woodcock
 May 17, 2022 at 14:08
Add a comment
8

Since you don't specify a language, I'll simply pick one at random. Here is a powershell script to do it:

$rootDir = 'C:\Temp\TestRandomFiles\'
$baseFile = $rootDir + "base.txt"
$desiredFileSize = 2*1KB
$fileCount = 50000
"start" | Out-File -Filepath $baseFile
While ($(Get-ChildItem -path $baseFile).Length -lt $desiredFileSize)
{
    $(Get-ChildItem -path $baseFile).Length | Out-File $baseFile -APPEND
}
for($i=1;$i -lt $fileCount;$i++)
{
    Copy-Item $baseFile "File$i.txt"
}
You'll have to change the variables to the parameters that you want of course.

Share
Improve this answer
Follow
answered Feb 10, 2009 at 19:47
EBGreen's user avatar
EBGreen
36.5k1212 gold badges6464 silver badges8484 bronze badges
1
oops...missed the random data requirement. Is that important? If so I can tweak it. – 
EBGreen
 Feb 10, 2009 at 19:48
1
If you are a PS whiz, I don't suppose you can do random data as I am keen to learn how this done! – 
Wil
 Jan 27, 2012 at 10:22 
I'm definitely not a whiz, but there are several ways. Basically you identify the data set that you want to randomize (say 0-9 and a-Z) then you randomly pick from that set to build the data for the file, then write it out to the file. If I have a chance later today, I'll alter the above code to use random data. – 
EBGreen
 Jan 27, 2012 at 15:12
@EBGreen thank You much! Best regards – 
Gennady G
 Nov 29, 2021 at 14:01
Add a comment
4

Instead of using Get-Random to generate the text as per user188737 & mguassa suggestions, I improved the speed by using GUIDs.

Function New-RandomFile {
    Param(
        $Path = '.', 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 
    (1..($FileSize/128)).foreach({-join ([guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-").SubString(1, 126) }) | set-content "$Path\$FileName"
}
This took 491 milliseconds to generate a 1mb file. Running:

New-RandomFile -FileSize 1mb
UPDATE:

I've updated my function to use a ScriptBlock, so you can replace the 'NewGuid()' method with anything you want.

In this scenario, I make 1kb chunks, since I know I'm never creating smaller files. This improved the speed of my function drastically!

Set-Content forces a NewLine at the end, which is why you need to remove 2 Characters each time you write to file. I've replaced it with [io.file]::WriteAllText() instead.

Function New-RandomFile_1kChunks {
    Param(
        $Path = (Resolve-Path '.').Path, 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 

    $Chunk = { [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-" }

    $Chunks = [math]::Ceiling($FileSize/1kb)

    [io.file]::WriteAllText("$Path\$FileName","$(-Join (1..($Chunks)).foreach({ $Chunk.Invoke() }))")

    Write-Warning "New-RandomFile: $Path\$FileName"

}
If you dont care that all chunks are random, you can simply Invoke() the generation of the 1kb chunk once.. this improves the speed drastically, but won't make the entire file random.

Function New-RandomFile_Fast {
    Param(
        $Path = (Resolve-Path '.').Path, 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 

    $Chunk = { [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-" }
    $Chunks = [math]::Ceiling($FileSize/1kb)
    $ChunkString = $Chunk.Invoke()

    [io.file]::WriteAllText("$Path\$FileName","$(-Join (1..($Chunks)).foreach({ $ChunkString }))")

    Write-Warning "New-RandomFile: $Path\$FileName"

}
Measure-Command all these changes to generate a 10mb file:

Executing New-RandomFile: 35.7688241 seconds.

Executing New-RandomFile_1kChunks: 25.1463777 seconds.

Executing New-RandomFile_Fast: 1.1626236 seconds.

Share
Improve this answer
Follow
edited Apr 3, 2017 at 23:04
answered Apr 1, 2017 at 2:39
Marc Kellerman's user avatar
Marc Kellerman
45622 silver badges1010 bronze badges
Add a comment
2

You'll have to create files in the normal way, and then populate them with randomized data, probably from a rand() function of some sort.

It really depends on your programming language. Windows itself certainly won't provide this capability.

There are a number of programming languages that could do this easily, however, including basic windows batch/CMD scripts. What language are you interested in using?

Share
Improve this answer
Follow
answered Feb 10, 2009 at 18:54
levand's user avatar
levand
8,39033 gold badges4040 silver badges5454 bronze badges
Add a comment
2

None of the answers here were cutting it for me, so here's a script which takes advantage of the Cryptography library to generate lots of random files.

This will generate files very quickly until your system's entropy is exhausted (on my PC this was about 4,000 files). After this it (and any other applications on your system that need cryptographic random numbers) will run very slowly. (In Linux terms, consider this script to use /dev/random instead of /dev/urandom)

$directory = (Get-Location).Path;
0..10000 | ForEach-Object {
    $size = 1023 * (Get-Random -Minimum 10 -Maximum 1536);
    $contents = [Byte[]]::new($size);

    $rng = [System.Security.Cryptography.RNGCryptoServiceProvider]::new();
    $rng.GetBytes($contents);

    $filename = "$directory\random$($_.ToString().PadLeft(5, '0')).txt"
    Write-Host $filename
    [System.IO.File]::WriteAllBytes($filename, $contents)
}
If you'd rather not deplete your system's entropy, replace the two $rng lines with these:

    $rng = [System.Random]::new();
    $rng.NextBytes($contents);
This will run much slower, but for large quantities of files (or larger files) it should be more reliable.

Share
Improve this answer
Follow
answered Apr 15, 2020 at 0:57
Joshua Walsh's user avatar
Joshua Walsh
1,88555 gold badges2525 silver badges5050 bronze badges
Add a comment
1

Yes, fsutil is great, but doesn't generate random data, just ASCII nulls.

I don't remember where I found this but searching on google these days I can still find it at: http://www.private-files.com/other/random.c.txt

I don't know how old this program is but at least as old as your question, probably somewhat older.

Anyway here's a program in C which creates files with a chi-squared test result of 0:

// ------------------------------------------------------------     
// Name: random.c  (program to create random files)
//     
// This "no-frills" program creates files with the following 
// characteristics: 
//
//    (1) Byte sequences are random (no predictability);
//    (2) Files produced are binary files; 
//    (3) File sizes are multiples of 256; 
//    (4) Files will have a chi-squared test result of 0
//        (see analyze.exe by Wenger for explanation)
//  
//              Programmer:  Scott Wenger
//                           Box 802
//                           Stevens Point, WI 54481
//                           panther@wctc.net
//
//       Note:  part of this code is from Knuth Volume II
// 
//  Enhancements and modifications of this program are left 
//  to the imagination and creativity of the programmer.
//  Check your compiler for required header files.  You may 
//  need to include the iostream header.
//
//  Random files are of potential use to cryptographers
//  for the purpose of encryption.  
//  
//  To analyze files produced by this program, see 
//  the analyze.exe program by Scott Wenger (found at
//  http://www.coredcs.com/sware.html)
// ------------------------------------------------------------


// This program works in the following way:
// The time is used to seed the random number generator.
// Using Knuth's algorithm, random numbers are generated
// in the range of 0 to 255 (corresponding to 256 ASCII chars.)
// When random numbers are generated they are marked as used and 
// are not re-used until all 256 ASCII values appear.  Characters 
// are written to disk and the process continues until the
// desired file size is reached.  Output is a random binary file
// called random.bin (placed in the root directory)
// The controlled filesize along with the placeholder feature 
// of this code forces a very high degree of randomness in 
// the output file. 

#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void init_mm();
void clear_array(); 
int  number_range(int minval, int maxval);
int  number_mm();

static int rgiState[2 + 55]; 
int place_holder[256];          // to keep track of numbers already generated

int main()
{
  mainprogram();
  return 0;
}

int mainprogram()
{
  int ch; 
  int c_used = 0;  // counter of chars in placeholder
  int done = 0; 
  int random;

  char buffer[2];

  long x;
  long byte_size = 0L;
  FILE *fp;

  clear_array();
  init_mm();  // seed random number generator

  // create a random file of length specified by user
  printf("\nrandom.exe originally by Scott Wenger");
  printf("\nThis program creates a random binary file.\n");
  printf("\nPlease specify length of random file to create (in megabytes): ");  

  scanf("%ld", &byte_size);

  while (byte_size > 1000 || byte_size <= 0 )
  {
    printf("\nWill not create files larger than a gigabyte! ");
    printf("\nPlease specify length of random file to create (in megabytes): ");
    flushall();
    scanf("%ld", &byte_size);
  }

  byte_size = byte_size * 1024 * 1024;

  if ( (fp = fopen("random.bin", "wb"))  == NULL) {
    fprintf(stderr, "\nOutput file (random.bin) could not be created.");      
    fflush(stdout);
    exit(1);
  }

  for (x = 0L; x < byte_size; x++) {

    if (c_used == 256) {
      clear_array();
      c_used = 0;
    }

    random = number_range(0, 255);    // use all ASCII values

    if ( *(place_holder + random) ) {  // already used, find another
      done = 0;
      while (!done) {
        random = number_range(0, 255);
        if ( *(place_holder + random) == 0) {
          *(place_holder + random) = 1;
          done = 1;
        }
      }         
    }
    else *(place_holder + random) = 1;  // use it and mark as used 

    c_used++;   // found next character so increment counter

    sprintf(buffer, "%c", random);  // convert ASCII value to char 
    ch = buffer[0];
    fputc(ch, fp); // write to file
  }

  fclose(fp);

  printf("\nDone. File \"random.bin\" was created (size: %ld bytes)", byte_size);
  printf("\nOutput file is in the root directory (c:\\random.bin)\n");
  return(0);
}

// ---------------------------------------------------------------------------------

void clear_array()
{
  register int x;
  for (x = 0; x < 256; x++) 
    *(place_holder + x) = 0;
}

// ---------------------------------------------------------------------------------

int number_mm()
{
    int *piState;
    int iState1;
    int iState2;
    int iRand;

    piState     = &rgiState[2];
    iState1     = piState[-2];
    iState2     = piState[-1];
    iRand       = ( piState[iState1] + piState[iState2] )
                & ( ( 1 << 30 ) - 1 );
    piState[iState1]    = iRand;

    if ( ++iState1 == 55 )  iState1 = 0;
    if ( ++iState2 == 55 )  iState2 = 0;

    piState[-2]     = iState1;
    piState[-1]     = iState2;

    return(iRand >> 6);
}

// ---------------------------------------------------------------------------------

//  Generate a random number.

int number_range( int minval, int maxval )
{
  int power, number;

  if ( ( maxval = maxval - minval + 1 ) <= 1 ) return (minval);

  for ( power = 2; power < maxval; power <<= 1 )
    ;
  while ( ( number = number_mm( ) & ( power - 1 ) ) >= maxval )
    ;
  return(minval + number);
}

// ---------------------------------------------------------------------------------

// Mitchell-Moore algorithm from Knuth Volume II. 

void init_mm( )
{
  int *piState;
  int iState;

  piState = &rgiState[2];
  piState[-2]   = 55 - 55;
  piState[-1]   = 55 - 24;
  piState[0]    = ( (int) time( NULL ) ) & ( ( 1 << 30 ) - 1 );
  piState[1]    = 1;

  for ( iState = 2; iState < 55; iState++ ) 
  {
    piState[iState] = ( piState[iState-1] + piState[iState-2] )
                      &  ( ( 1 << 30 ) - 1 );
  }
}

// -------------------- End -------------------------------------------------------
Share
Improve this answer
Follow
answered Aug 10, 2016 at 13:38
Rubenisme's user avatar
Rubenisme
78711 gold badge88 silver badges1515 bronze badges
Add a comment
1

So, i decided to add an accurate answer this time.

language is powershell. assumptions: filenames will be sequential and not random. file contents are to be cryptographically secure and unique. file location to be C:\temp\

#create a fixed size byte array for later use.  make it the required file size.
$bytearray = New-Object byte[] 2048

#create and start a stopwatch object to measure how long it all takes.
$stopwatch = [Diagnostics.Stopwatch]::StartNew()

#create a CSRNG object
$RNGObject = New-Object Security.Cryptography.RNGCryptoServiceProvider

# set up a loop to run 50000 times
0..49999 | Foreach-Object {

    # create a file stream handle with a name format 'filennnnn'
    $stream = New-Object System.IO.FileStream("c:\temp\file$("{0:D5}" -f $_)"), Create

    # and a stream writer handle
    $writer = New-Object System.IO.BinaryWriter($stream)

    # Fill our array from the CSRNG
    $RNGObject.GetNonZeroBytes($bytearray)

    # Append to the current file
    $writer.write($bytearray)

    # Close the stream
    $stream.close()

}
About
Products
For Teams
Search…
Join Stack Overflow to find the best answer to your technical question, help others answer theirs.

Home
PUBLIC
Questions
Tags
Users
Companies
COLLECTIVES
Explore Collectives
TEAMS
Stack Overflow for Teams – Start collaborating and sharing organizational knowledge. 
Generating Random Files in Windows
Asked 14 years, 3 months ago
Modified 5 months ago
Viewed 85k times
42

Does anyone have a way to generate files of random data in Windows? I would like to generate 50,000 small (2K) files as an example.

windows
Share
Improve this question
Follow
asked Feb 10, 2009 at 18:51
Jeff
2
Could you share with us whether you want text files or binary files? Could you also comment as to what programming languages you have access to (if any)? Do you have MS Office installed? Also, not very relevant, but what version of windows are you using? – 
user62572
 Feb 10, 2009 at 20:05
Add a comment
16 Answers
Sorted by:

Highest score (default)
34

You can run fsutil in a batch loop to create files of any size.

fsutil file createnew filename.extension 2000
Share
Improve this answer
Follow
answered Feb 10, 2009 at 19:01
Bogdan's user avatar
Bogdan
3,03511 gold badge2222 silver badges2020 bronze badges
I just found that utility. Didn't know it existed before. thebackroomtech.com/2009/01/16/… – 
beach
 Feb 10, 2009 at 19:04
41
However, it doesn't create random data. Just blank files. – 
beach
 Feb 10, 2009 at 19:07
And it seems to require admin permissions. Going with the powershell. – 
Mathias Mamsch
 Oct 25, 2017 at 7:21
Add a comment
21

One-liner in Powershell:

$out = new-object byte[] 1048576; (new-object Random).NextBytes($out); [IO.File]::WriteAllBytes('d:\file.bin', $out)
This is lightning fast, compared to @user188737 solution.

Share
Improve this answer
Follow
answered Sep 26, 2017 at 7:07
gwiazdorrr's user avatar
gwiazdorrr
6,16122 gold badges2727 silver badges3636 bronze badges
1
Every single file that this one liner creates is identical. Is there any way to make the content of each file different – 
Dhiwakar Ravikumar
 Apr 15, 2018 at 4:47
3
Are you sure this is the case? I tried it on my system, ran it 3 times, got 3 distinct files. The constructor for the Random type is by default based on the system time, so perhaps if you run this multiple times in very quick succession, you might get identical files. You could avoid this by creating a single Random object and then reusing it for each consecutive file: $rnd = New-Object Random; once at the top, and then $rnd.NextBytes instead of (New-Object Random).NextBytes when generating the file. – 
Jonathan Gilbert
 May 29, 2018 at 16:19
Add a comment
18

You can use PowerShell to generate cheap random data for your files:

[Byte[]] $out = @()
0..2047 | % {$out += Get-Random -Minimum 0 -Maximum 255}
[System.IO.File]::WriteAllBytes("myrandomfiletest", $out)
This uses an algorithm with a seed taken from the system clock, so don't use this for ANY serious cryptographic applications.

In addition, be wary of the performance degradation of Get-Random when increasing the size of the output file. More on this aspect here:

PowerShell random file generator too slow
Improve Powershell Performance to Generate a Random File
Share
Improve this answer
Follow
edited May 23, 2017 at 12:32
Community's user avatar
CommunityBot
111 silver badge
answered Sep 27, 2013 at 18:23
Gerrit's user avatar
Gerrit
85166 silver badges1111 bronze badges
Add a comment
16

I have been using Random Data File Creator and liking it, it creates binary files (i.e. not text files) filled with pseudo-random bits, it can quickly create very large files. To use it to create multiple small files you would need to script it, which would be very easy given it is command line.

Share
Improve this answer
Follow
edited Dec 25, 2015 at 11:57
mguassa's user avatar
mguassa
3,97122 gold badges1414 silver badges1919 bronze badges
answered Feb 5, 2010 at 19:20
David Waters's user avatar
David Waters
11.9k77 gold badges4141 silver badges7676 bronze badges
There are quite a few programs and cloud tools of this nature: raywoodcockslatest.wordpress.com/2021/08/21/dummy-files – 
Ray Woodcock
 May 17, 2022 at 14:08
Add a comment
8

Since you don't specify a language, I'll simply pick one at random. Here is a powershell script to do it:

$rootDir = 'C:\Temp\TestRandomFiles\'
$baseFile = $rootDir + "base.txt"
$desiredFileSize = 2*1KB
$fileCount = 50000
"start" | Out-File -Filepath $baseFile
While ($(Get-ChildItem -path $baseFile).Length -lt $desiredFileSize)
{
    $(Get-ChildItem -path $baseFile).Length | Out-File $baseFile -APPEND
}
for($i=1;$i -lt $fileCount;$i++)
{
    Copy-Item $baseFile "File$i.txt"
}
You'll have to change the variables to the parameters that you want of course.

Share
Improve this answer
Follow
answered Feb 10, 2009 at 19:47
EBGreen's user avatar
EBGreen
36.5k1212 gold badges6464 silver badges8484 bronze badges
1
oops...missed the random data requirement. Is that important? If so I can tweak it. – 
EBGreen
 Feb 10, 2009 at 19:48
1
If you are a PS whiz, I don't suppose you can do random data as I am keen to learn how this done! – 
Wil
 Jan 27, 2012 at 10:22 
I'm definitely not a whiz, but there are several ways. Basically you identify the data set that you want to randomize (say 0-9 and a-Z) then you randomly pick from that set to build the data for the file, then write it out to the file. If I have a chance later today, I'll alter the above code to use random data. – 
EBGreen
 Jan 27, 2012 at 15:12
@EBGreen thank You much! Best regards – 
Gennady G
 Nov 29, 2021 at 14:01
Add a comment
4

Instead of using Get-Random to generate the text as per user188737 & mguassa suggestions, I improved the speed by using GUIDs.

Function New-RandomFile {
    Param(
        $Path = '.', 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 
    (1..($FileSize/128)).foreach({-join ([guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-").SubString(1, 126) }) | set-content "$Path\$FileName"
}
This took 491 milliseconds to generate a 1mb file. Running:

New-RandomFile -FileSize 1mb
UPDATE:

I've updated my function to use a ScriptBlock, so you can replace the 'NewGuid()' method with anything you want.

In this scenario, I make 1kb chunks, since I know I'm never creating smaller files. This improved the speed of my function drastically!

Set-Content forces a NewLine at the end, which is why you need to remove 2 Characters each time you write to file. I've replaced it with [io.file]::WriteAllText() instead.

Function New-RandomFile_1kChunks {
    Param(
        $Path = (Resolve-Path '.').Path, 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 

    $Chunk = { [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-" }

    $Chunks = [math]::Ceiling($FileSize/1kb)

    [io.file]::WriteAllText("$Path\$FileName","$(-Join (1..($Chunks)).foreach({ $Chunk.Invoke() }))")

    Write-Warning "New-RandomFile: $Path\$FileName"

}
If you dont care that all chunks are random, you can simply Invoke() the generation of the 1kb chunk once.. this improves the speed drastically, but won't make the entire file random.

Function New-RandomFile_Fast {
    Param(
        $Path = (Resolve-Path '.').Path, 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 

    $Chunk = { [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-" }
    $Chunks = [math]::Ceiling($FileSize/1kb)
    $ChunkString = $Chunk.Invoke()

    [io.file]::WriteAllText("$Path\$FileName","$(-Join (1..($Chunks)).foreach({ $ChunkString }))")

    Write-Warning "New-RandomFile: $Path\$FileName"

}
Measure-Command all these changes to generate a 10mb file:

Executing New-RandomFile: 35.7688241 seconds.

Executing New-RandomFile_1kChunks: 25.1463777 seconds.

Executing New-RandomFile_Fast: 1.1626236 seconds.

Share
Improve this answer
Follow
edited Apr 3, 2017 at 23:04
answered Apr 1, 2017 at 2:39
Marc Kellerman's user avatar
Marc Kellerman
45622 silver badges1010 bronze badges
Add a comment
2

You'll have to create files in the normal way, and then populate them with randomized data, probably from a rand() function of some sort.

It really depends on your programming language. Windows itself certainly won't provide this capability.

There are a number of programming languages that could do this easily, however, including basic windows batch/CMD scripts. What language are you interested in using?

Share
Improve this answer
Follow
answered Feb 10, 2009 at 18:54
levand's user avatar
levand
8,39033 gold badges4040 silver badges5454 bronze badges
Add a comment
2

None of the answers here were cutting it for me, so here's a script which takes advantage of the Cryptography library to generate lots of random files.

This will generate files very quickly until your system's entropy is exhausted (on my PC this was about 4,000 files). After this it (and any other applications on your system that need cryptographic random numbers) will run very slowly. (In Linux terms, consider this script to use /dev/random instead of /dev/urandom)

$directory = (Get-Location).Path;
0..10000 | ForEach-Object {
    $size = 1023 * (Get-Random -Minimum 10 -Maximum 1536);
    $contents = [Byte[]]::new($size);

    $rng = [System.Security.Cryptography.RNGCryptoServiceProvider]::new();
    $rng.GetBytes($contents);

    $filename = "$directory\random$($_.ToString().PadLeft(5, '0')).txt"
    Write-Host $filename
    [System.IO.File]::WriteAllBytes($filename, $contents)
}
If you'd rather not deplete your system's entropy, replace the two $rng lines with these:

    $rng = [System.Random]::new();
    $rng.NextBytes($contents);
This will run much slower, but for large quantities of files (or larger files) it should be more reliable.

Share
Improve this answer
Follow
answered Apr 15, 2020 at 0:57
Joshua Walsh's user avatar
Joshua Walsh
1,88555 gold badges2525 silver badges5050 bronze badges
Add a comment
1

Yes, fsutil is great, but doesn't generate random data, just ASCII nulls.

I don't remember where I found this but searching on google these days I can still find it at: http://www.private-files.com/other/random.c.txt

I don't know how old this program is but at least as old as your question, probably somewhat older.

Anyway here's a program in C which creates files with a chi-squared test result of 0:

// ------------------------------------------------------------     
// Name: random.c  (program to create random files)
//     
// This "no-frills" program creates files with the following 
// characteristics: 
//
//    (1) Byte sequences are random (no predictability);
//    (2) Files produced are binary files; 
//    (3) File sizes are multiples of 256; 
//    (4) Files will have a chi-squared test result of 0
//        (see analyze.exe by Wenger for explanation)
//  
//              Programmer:  Scott Wenger
//                           Box 802
//                           Stevens Point, WI 54481
//                           panther@wctc.net
//
//       Note:  part of this code is from Knuth Volume II
// 
//  Enhancements and modifications of this program are left 
//  to the imagination and creativity of the programmer.
//  Check your compiler for required header files.  You may 
//  need to include the iostream header.
//
//  Random files are of potential use to cryptographers
//  for the purpose of encryption.  
//  
//  To analyze files produced by this program, see 
//  the analyze.exe program by Scott Wenger (found at
//  http://www.coredcs.com/sware.html)
// ------------------------------------------------------------


// This program works in the following way:
// The time is used to seed the random number generator.
// Using Knuth's algorithm, random numbers are generated
// in the range of 0 to 255 (corresponding to 256 ASCII chars.)
// When random numbers are generated they are marked as used and 
// are not re-used until all 256 ASCII values appear.  Characters 
// are written to disk and the process continues until the
// desired file size is reached.  Output is a random binary file
// called random.bin (placed in the root directory)
// The controlled filesize along with the placeholder feature 
// of this code forces a very high degree of randomness in 
// the output file. 

#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void init_mm();
void clear_array(); 
int  number_range(int minval, int maxval);
int  number_mm();

static int rgiState[2 + 55]; 
int place_holder[256];          // to keep track of numbers already generated

int main()
{
  mainprogram();
  return 0;
}

int mainprogram()
{
  int ch; 
  int c_used = 0;  // counter of chars in placeholder
  int done = 0; 
  int random;

  char buffer[2];

  long x;
  long byte_size = 0L;
  FILE *fp;

  clear_array();
  init_mm();  // seed random number generator

  // create a random file of length specified by user
  printf("\nrandom.exe originally by Scott Wenger");
  printf("\nThis program creates a random binary file.\n");
  printf("\nPlease specify length of random file to create (in megabytes): ");  

  scanf("%ld", &byte_size);

  while (byte_size > 1000 || byte_size <= 0 )
  {
    printf("\nWill not create files larger than a gigabyte! ");
    printf("\nPlease specify length of random file to create (in megabytes): ");
    flushall();
    scanf("%ld", &byte_size);
  }

  byte_size = byte_size * 1024 * 1024;

  if ( (fp = fopen("random.bin", "wb"))  == NULL) {
    fprintf(stderr, "\nOutput file (random.bin) could not be created.");      
    fflush(stdout);
    exit(1);
  }

  for (x = 0L; x < byte_size; x++) {

    if (c_used == 256) {
      clear_array();
      c_used = 0;
    }

    random = number_range(0, 255);    // use all ASCII values

    if ( *(place_holder + random) ) {  // already used, find another
      done = 0;
      while (!done) {
        random = number_range(0, 255);
        if ( *(place_holder + random) == 0) {
          *(place_holder + random) = 1;
          done = 1;
        }
      }         
    }
    else *(place_holder + random) = 1;  // use it and mark as used 

    c_used++;   // found next character so increment counter

    sprintf(buffer, "%c", random);  // convert ASCII value to char 
    ch = buffer[0];
    fputc(ch, fp); // write to file
  }

  fclose(fp);

  printf("\nDone. File \"random.bin\" was created (size: %ld bytes)", byte_size);
  printf("\nOutput file is in the root directory (c:\\random.bin)\n");
  return(0);
}

// ---------------------------------------------------------------------------------

void clear_array()
{
  register int x;
  for (x = 0; x < 256; x++) 
    *(place_holder + x) = 0;
}

// ---------------------------------------------------------------------------------

int number_mm()
{
    int *piState;
    int iState1;
    int iState2;
    int iRand;

    piState     = &rgiState[2];
    iState1     = piState[-2];
    iState2     = piState[-1];
    iRand       = ( piState[iState1] + piState[iState2] )
                & ( ( 1 << 30 ) - 1 );
    piState[iState1]    = iRand;

    if ( ++iState1 == 55 )  iState1 = 0;
    if ( ++iState2 == 55 )  iState2 = 0;

    piState[-2]     = iState1;
    piState[-1]     = iState2;

    return(iRand >> 6);
}

// ---------------------------------------------------------------------------------

//  Generate a random number.

int number_range( int minval, int maxval )
{
  int power, number;

  if ( ( maxval = maxval - minval + 1 ) <= 1 ) return (minval);

  for ( power = 2; power < maxval; power <<= 1 )
    ;
  while ( ( number = number_mm( ) & ( power - 1 ) ) >= maxval )
    ;
  return(minval + number);
}

// ---------------------------------------------------------------------------------

// Mitchell-Moore algorithm from Knuth Volume II. 

void init_mm( )
{
  int *piState;
  int iState;

  piState = &rgiState[2];
  piState[-2]   = 55 - 55;
  piState[-1]   = 55 - 24;
  piState[0]    = ( (int) time( NULL ) ) & ( ( 1 << 30 ) - 1 );
  piState[1]    = 1;

  for ( iState = 2; iState < 55; iState++ ) 
  {
    piState[iState] = ( piState[iState-1] + piState[iState-2] )
                      &  ( ( 1 << 30 ) - 1 );
  }
}

// -------------------- End -------------------------------------------------------
Share
Improve this answer
Follow
answered Aug 10, 2016 at 13:38
Rubenisme's user avatar
Rubenisme
78711 gold badge88 silver badges1515 bronze badges
Add a comment
1

So, i decided to add an accurate answer this time.

language is powershell. assumptions: filenames will be sequential and not random. file contents are to be cryptographically secure and unique. file location to be C:\temp\

#create a fixed size byte array for later use.  make it the required file size.
$bytearray = New-Object byte[] 2048

#create and start a stopwatch object to measure how long it all takes.
$stopwatch = [Diagnostics.Stopwatch]::StartNew()

#create a CSRNG object
$RNGObject = New-Object Security.Cryptography.RNGCryptoServiceProvider

# set up a loop to run 50000 times
0..49999 | Foreach-Object {

    # create a file stream handle with a name format 'filennnnn'
    $stream = New-Object System.IO.FileStream("c:\temp\file$("{0:D5}" -f $_)"), Create

    # and a stream writer handle
    $writer = New-Object System.IO.BinaryWriter($stream)

    # Fill our array from the CSRNG
    $RNGObject.GetNonZeroBytes($bytearray)

    # Append to the current file
    $writer.write($bytearray)

    # Close the stream
    $stream.close()

}
About
Products
For Teams
Search…
Join Stack Overflow to find the best answer to your technical question, help others answer theirs.

Home
PUBLIC
Questions
Tags
Users
Companies
COLLECTIVES
Explore Collectives
TEAMS
Stack Overflow for Teams – Start collaborating and sharing organizational knowledge. 
Generating Random Files in Windows
Asked 14 years, 3 months ago
Modified 5 months ago
Viewed 85k times
42

Does anyone have a way to generate files of random data in Windows? I would like to generate 50,000 small (2K) files as an example.

windows
Share
Improve this question
Follow
asked Feb 10, 2009 at 18:51
Jeff
2
Could you share with us whether you want text files or binary files? Could you also comment as to what programming languages you have access to (if any)? Do you have MS Office installed? Also, not very relevant, but what version of windows are you using? – 
user62572
 Feb 10, 2009 at 20:05
Add a comment
16 Answers
Sorted by:

Highest score (default)
34

You can run fsutil in a batch loop to create files of any size.

fsutil file createnew filename.extension 2000
Share
Improve this answer
Follow
answered Feb 10, 2009 at 19:01
Bogdan's user avatar
Bogdan
3,03511 gold badge2222 silver badges2020 bronze badges
I just found that utility. Didn't know it existed before. thebackroomtech.com/2009/01/16/… – 
beach
 Feb 10, 2009 at 19:04
41
However, it doesn't create random data. Just blank files. – 
beach
 Feb 10, 2009 at 19:07
And it seems to require admin permissions. Going with the powershell. – 
Mathias Mamsch
 Oct 25, 2017 at 7:21
Add a comment
21

One-liner in Powershell:

$out = new-object byte[] 1048576; (new-object Random).NextBytes($out); [IO.File]::WriteAllBytes('d:\file.bin', $out)
This is lightning fast, compared to @user188737 solution.

Share
Improve this answer
Follow
answered Sep 26, 2017 at 7:07
gwiazdorrr's user avatar
gwiazdorrr
6,16122 gold badges2727 silver badges3636 bronze badges
1
Every single file that this one liner creates is identical. Is there any way to make the content of each file different – 
Dhiwakar Ravikumar
 Apr 15, 2018 at 4:47
3
Are you sure this is the case? I tried it on my system, ran it 3 times, got 3 distinct files. The constructor for the Random type is by default based on the system time, so perhaps if you run this multiple times in very quick succession, you might get identical files. You could avoid this by creating a single Random object and then reusing it for each consecutive file: $rnd = New-Object Random; once at the top, and then $rnd.NextBytes instead of (New-Object Random).NextBytes when generating the file. – 
Jonathan Gilbert
 May 29, 2018 at 16:19
Add a comment
18

You can use PowerShell to generate cheap random data for your files:

[Byte[]] $out = @()
0..2047 | % {$out += Get-Random -Minimum 0 -Maximum 255}
[System.IO.File]::WriteAllBytes("myrandomfiletest", $out)
This uses an algorithm with a seed taken from the system clock, so don't use this for ANY serious cryptographic applications.

In addition, be wary of the performance degradation of Get-Random when increasing the size of the output file. More on this aspect here:

PowerShell random file generator too slow
Improve Powershell Performance to Generate a Random File
Share
Improve this answer
Follow
edited May 23, 2017 at 12:32
Community's user avatar
CommunityBot
111 silver badge
answered Sep 27, 2013 at 18:23
Gerrit's user avatar
Gerrit
85166 silver badges1111 bronze badges
Add a comment
16

I have been using Random Data File Creator and liking it, it creates binary files (i.e. not text files) filled with pseudo-random bits, it can quickly create very large files. To use it to create multiple small files you would need to script it, which would be very easy given it is command line.

Share
Improve this answer
Follow
edited Dec 25, 2015 at 11:57
mguassa's user avatar
mguassa
3,97122 gold badges1414 silver badges1919 bronze badges
answered Feb 5, 2010 at 19:20
David Waters's user avatar
David Waters
11.9k77 gold badges4141 silver badges7676 bronze badges
There are quite a few programs and cloud tools of this nature: raywoodcockslatest.wordpress.com/2021/08/21/dummy-files – 
Ray Woodcock
 May 17, 2022 at 14:08
Add a comment
8

Since you don't specify a language, I'll simply pick one at random. Here is a powershell script to do it:

$rootDir = 'C:\Temp\TestRandomFiles\'
$baseFile = $rootDir + "base.txt"
$desiredFileSize = 2*1KB
$fileCount = 50000
"start" | Out-File -Filepath $baseFile
While ($(Get-ChildItem -path $baseFile).Length -lt $desiredFileSize)
{
    $(Get-ChildItem -path $baseFile).Length | Out-File $baseFile -APPEND
}
for($i=1;$i -lt $fileCount;$i++)
{
    Copy-Item $baseFile "File$i.txt"
}
You'll have to change the variables to the parameters that you want of course.

Share
Improve this answer
Follow
answered Feb 10, 2009 at 19:47
EBGreen's user avatar
EBGreen
36.5k1212 gold badges6464 silver badges8484 bronze badges
1
oops...missed the random data requirement. Is that important? If so I can tweak it. – 
EBGreen
 Feb 10, 2009 at 19:48
1
If you are a PS whiz, I don't suppose you can do random data as I am keen to learn how this done! – 
Wil
 Jan 27, 2012 at 10:22 
I'm definitely not a whiz, but there are several ways. Basically you identify the data set that you want to randomize (say 0-9 and a-Z) then you randomly pick from that set to build the data for the file, then write it out to the file. If I have a chance later today, I'll alter the above code to use random data. – 
EBGreen
 Jan 27, 2012 at 15:12
@EBGreen thank You much! Best regards – 
Gennady G
 Nov 29, 2021 at 14:01
Add a comment
4

Instead of using Get-Random to generate the text as per user188737 & mguassa suggestions, I improved the speed by using GUIDs.

Function New-RandomFile {
    Param(
        $Path = '.', 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 
    (1..($FileSize/128)).foreach({-join ([guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-").SubString(1, 126) }) | set-content "$Path\$FileName"
}
This took 491 milliseconds to generate a 1mb file. Running:

New-RandomFile -FileSize 1mb
UPDATE:

I've updated my function to use a ScriptBlock, so you can replace the 'NewGuid()' method with anything you want.

In this scenario, I make 1kb chunks, since I know I'm never creating smaller files. This improved the speed of my function drastically!

Set-Content forces a NewLine at the end, which is why you need to remove 2 Characters each time you write to file. I've replaced it with [io.file]::WriteAllText() instead.

Function New-RandomFile_1kChunks {
    Param(
        $Path = (Resolve-Path '.').Path, 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 

    $Chunk = { [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-" }

    $Chunks = [math]::Ceiling($FileSize/1kb)

    [io.file]::WriteAllText("$Path\$FileName","$(-Join (1..($Chunks)).foreach({ $Chunk.Invoke() }))")

    Write-Warning "New-RandomFile: $Path\$FileName"

}
If you dont care that all chunks are random, you can simply Invoke() the generation of the 1kb chunk once.. this improves the speed drastically, but won't make the entire file random.

Function New-RandomFile_Fast {
    Param(
        $Path = (Resolve-Path '.').Path, 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 

    $Chunk = { [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-" }
    $Chunks = [math]::Ceiling($FileSize/1kb)
    $ChunkString = $Chunk.Invoke()

    [io.file]::WriteAllText("$Path\$FileName","$(-Join (1..($Chunks)).foreach({ $ChunkString }))")

    Write-Warning "New-RandomFile: $Path\$FileName"

}
Measure-Command all these changes to generate a 10mb file:

Executing New-RandomFile: 35.7688241 seconds.

Executing New-RandomFile_1kChunks: 25.1463777 seconds.

Executing New-RandomFile_Fast: 1.1626236 seconds.

Share
Improve this answer
Follow
edited Apr 3, 2017 at 23:04
answered Apr 1, 2017 at 2:39
Marc Kellerman's user avatar
Marc Kellerman
45622 silver badges1010 bronze badges
Add a comment
2

You'll have to create files in the normal way, and then populate them with randomized data, probably from a rand() function of some sort.

It really depends on your programming language. Windows itself certainly won't provide this capability.

There are a number of programming languages that could do this easily, however, including basic windows batch/CMD scripts. What language are you interested in using?

Share
Improve this answer
Follow
answered Feb 10, 2009 at 18:54
levand's user avatar
levand
8,39033 gold badges4040 silver badges5454 bronze badges
Add a comment
2

None of the answers here were cutting it for me, so here's a script which takes advantage of the Cryptography library to generate lots of random files.

This will generate files very quickly until your system's entropy is exhausted (on my PC this was about 4,000 files). After this it (and any other applications on your system that need cryptographic random numbers) will run very slowly. (In Linux terms, consider this script to use /dev/random instead of /dev/urandom)

$directory = (Get-Location).Path;
0..10000 | ForEach-Object {
    $size = 1023 * (Get-Random -Minimum 10 -Maximum 1536);
    $contents = [Byte[]]::new($size);

    $rng = [System.Security.Cryptography.RNGCryptoServiceProvider]::new();
    $rng.GetBytes($contents);

    $filename = "$directory\random$($_.ToString().PadLeft(5, '0')).txt"
    Write-Host $filename
    [System.IO.File]::WriteAllBytes($filename, $contents)
}
If you'd rather not deplete your system's entropy, replace the two $rng lines with these:

    $rng = [System.Random]::new();
    $rng.NextBytes($contents);
This will run much slower, but for large quantities of files (or larger files) it should be more reliable.

Share
Improve this answer
Follow
answered Apr 15, 2020 at 0:57
Joshua Walsh's user avatar
Joshua Walsh
1,88555 gold badges2525 silver badges5050 bronze badges
Add a comment
1

Yes, fsutil is great, but doesn't generate random data, just ASCII nulls.

I don't remember where I found this but searching on google these days I can still find it at: http://www.private-files.com/other/random.c.txt

I don't know how old this program is but at least as old as your question, probably somewhat older.

Anyway here's a program in C which creates files with a chi-squared test result of 0:

// ------------------------------------------------------------     
// Name: random.c  (program to create random files)
//     
// This "no-frills" program creates files with the following 
// characteristics: 
//
//    (1) Byte sequences are random (no predictability);
//    (2) Files produced are binary files; 
//    (3) File sizes are multiples of 256; 
//    (4) Files will have a chi-squared test result of 0
//        (see analyze.exe by Wenger for explanation)
//  
//              Programmer:  Scott Wenger
//                           Box 802
//                           Stevens Point, WI 54481
//                           panther@wctc.net
//
//       Note:  part of this code is from Knuth Volume II
// 
//  Enhancements and modifications of this program are left 
//  to the imagination and creativity of the programmer.
//  Check your compiler for required header files.  You may 
//  need to include the iostream header.
//
//  Random files are of potential use to cryptographers
//  for the purpose of encryption.  
//  
//  To analyze files produced by this program, see 
//  the analyze.exe program by Scott Wenger (found at
//  http://www.coredcs.com/sware.html)
// ------------------------------------------------------------


// This program works in the following way:
// The time is used to seed the random number generator.
// Using Knuth's algorithm, random numbers are generated
// in the range of 0 to 255 (corresponding to 256 ASCII chars.)
// When random numbers are generated they are marked as used and 
// are not re-used until all 256 ASCII values appear.  Characters 
// are written to disk and the process continues until the
// desired file size is reached.  Output is a random binary file
// called random.bin (placed in the root directory)
// The controlled filesize along with the placeholder feature 
// of this code forces a very high degree of randomness in 
// the output file. 

#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void init_mm();
void clear_array(); 
int  number_range(int minval, int maxval);
int  number_mm();

static int rgiState[2 + 55]; 
int place_holder[256];          // to keep track of numbers already generated

int main()
{
  mainprogram();
  return 0;
}

int mainprogram()
{
  int ch; 
  int c_used = 0;  // counter of chars in placeholder
  int done = 0; 
  int random;

  char buffer[2];

  long x;
  long byte_size = 0L;
  FILE *fp;

  clear_array();
  init_mm();  // seed random number generator

  // create a random file of length specified by user
  printf("\nrandom.exe originally by Scott Wenger");
  printf("\nThis program creates a random binary file.\n");
  printf("\nPlease specify length of random file to create (in megabytes): ");  

  scanf("%ld", &byte_size);

  while (byte_size > 1000 || byte_size <= 0 )
  {
    printf("\nWill not create files larger than a gigabyte! ");
    printf("\nPlease specify length of random file to create (in megabytes): ");
    flushall();
    scanf("%ld", &byte_size);
  }

  byte_size = byte_size * 1024 * 1024;

  if ( (fp = fopen("random.bin", "wb"))  == NULL) {
    fprintf(stderr, "\nOutput file (random.bin) could not be created.");      
    fflush(stdout);
    exit(1);
  }

  for (x = 0L; x < byte_size; x++) {

    if (c_used == 256) {
      clear_array();
      c_used = 0;
    }

    random = number_range(0, 255);    // use all ASCII values

    if ( *(place_holder + random) ) {  // already used, find another
      done = 0;
      while (!done) {
        random = number_range(0, 255);
        if ( *(place_holder + random) == 0) {
          *(place_holder + random) = 1;
          done = 1;
        }
      }         
    }
    else *(place_holder + random) = 1;  // use it and mark as used 

    c_used++;   // found next character so increment counter

    sprintf(buffer, "%c", random);  // convert ASCII value to char 
    ch = buffer[0];
    fputc(ch, fp); // write to file
  }

  fclose(fp);

  printf("\nDone. File \"random.bin\" was created (size: %ld bytes)", byte_size);
  printf("\nOutput file is in the root directory (c:\\random.bin)\n");
  return(0);
}

// ---------------------------------------------------------------------------------

void clear_array()
{
  register int x;
  for (x = 0; x < 256; x++) 
    *(place_holder + x) = 0;
}

// ---------------------------------------------------------------------------------

int number_mm()
{
    int *piState;
    int iState1;
    int iState2;
    int iRand;

    piState     = &rgiState[2];
    iState1     = piState[-2];
    iState2     = piState[-1];
    iRand       = ( piState[iState1] + piState[iState2] )
                & ( ( 1 << 30 ) - 1 );
    piState[iState1]    = iRand;

    if ( ++iState1 == 55 )  iState1 = 0;
    if ( ++iState2 == 55 )  iState2 = 0;

    piState[-2]     = iState1;
    piState[-1]     = iState2;

    return(iRand >> 6);
}

// ---------------------------------------------------------------------------------

//  Generate a random number.

int number_range( int minval, int maxval )
{
  int power, number;

  if ( ( maxval = maxval - minval + 1 ) <= 1 ) return (minval);

  for ( power = 2; power < maxval; power <<= 1 )
    ;
  while ( ( number = number_mm( ) & ( power - 1 ) ) >= maxval )
    ;
  return(minval + number);
}

// ---------------------------------------------------------------------------------

// Mitchell-Moore algorithm from Knuth Volume II. 

void init_mm( )
{
  int *piState;
  int iState;

  piState = &rgiState[2];
  piState[-2]   = 55 - 55;
  piState[-1]   = 55 - 24;
  piState[0]    = ( (int) time( NULL ) ) & ( ( 1 << 30 ) - 1 );
  piState[1]    = 1;

  for ( iState = 2; iState < 55; iState++ ) 
  {
    piState[iState] = ( piState[iState-1] + piState[iState-2] )
                      &  ( ( 1 << 30 ) - 1 );
  }
}

// -------------------- End -------------------------------------------------------
Share
Improve this answer
Follow
answered Aug 10, 2016 at 13:38
Rubenisme's user avatar
Rubenisme
78711 gold badge88 silver badges1515 bronze badges
Add a comment
1

So, i decided to add an accurate answer this time.

language is powershell. assumptions: filenames will be sequential and not random. file contents are to be cryptographically secure and unique. file location to be C:\temp\

#create a fixed size byte array for later use.  make it the required file size.
$bytearray = New-Object byte[] 2048

#create and start a stopwatch object to measure how long it all takes.
$stopwatch = [Diagnostics.Stopwatch]::StartNew()

#create a CSRNG object
$RNGObject = New-Object Security.Cryptography.RNGCryptoServiceProvider

# set up a loop to run 50000 times
0..49999 | Foreach-Object {

    # create a file stream handle with a name format 'filennnnn'
    $stream = New-Object System.IO.FileStream("c:\temp\file$("{0:D5}" -f $_)"), Create

    # and a stream writer handle
    $writer = New-Object System.IO.BinaryWriter($stream)

    # Fill our array from the CSRNG
    $RNGObject.GetNonZeroBytes($bytearray)

    # Append to the current file
    $writer.write($bytearray)

    # Close the stream
    $stream.close()

}
About
Products
For Teams
Search…
Join Stack Overflow to find the best answer to your technical question, help others answer theirs.

Home
PUBLIC
Questions
Tags
Users
Companies
COLLECTIVES
Explore Collectives
TEAMS
Stack Overflow for Teams – Start collaborating and sharing organizational knowledge. 
Generating Random Files in Windows
Asked 14 years, 3 months ago
Modified 5 months ago
Viewed 85k times
42

Does anyone have a way to generate files of random data in Windows? I would like to generate 50,000 small (2K) files as an example.

windows
Share
Improve this question
Follow
asked Feb 10, 2009 at 18:51
Jeff
2
Could you share with us whether you want text files or binary files? Could you also comment as to what programming languages you have access to (if any)? Do you have MS Office installed? Also, not very relevant, but what version of windows are you using? – 
user62572
 Feb 10, 2009 at 20:05
Add a comment
16 Answers
Sorted by:

Highest score (default)
34

You can run fsutil in a batch loop to create files of any size.

fsutil file createnew filename.extension 2000
Share
Improve this answer
Follow
answered Feb 10, 2009 at 19:01
Bogdan's user avatar
Bogdan
3,03511 gold badge2222 silver badges2020 bronze badges
I just found that utility. Didn't know it existed before. thebackroomtech.com/2009/01/16/… – 
beach
 Feb 10, 2009 at 19:04
41
However, it doesn't create random data. Just blank files. – 
beach
 Feb 10, 2009 at 19:07
And it seems to require admin permissions. Going with the powershell. – 
Mathias Mamsch
 Oct 25, 2017 at 7:21
Add a comment
21

One-liner in Powershell:

$out = new-object byte[] 1048576; (new-object Random).NextBytes($out); [IO.File]::WriteAllBytes('d:\file.bin', $out)
This is lightning fast, compared to @user188737 solution.

Share
Improve this answer
Follow
answered Sep 26, 2017 at 7:07
gwiazdorrr's user avatar
gwiazdorrr
6,16122 gold badges2727 silver badges3636 bronze badges
1
Every single file that this one liner creates is identical. Is there any way to make the content of each file different – 
Dhiwakar Ravikumar
 Apr 15, 2018 at 4:47
3
Are you sure this is the case? I tried it on my system, ran it 3 times, got 3 distinct files. The constructor for the Random type is by default based on the system time, so perhaps if you run this multiple times in very quick succession, you might get identical files. You could avoid this by creating a single Random object and then reusing it for each consecutive file: $rnd = New-Object Random; once at the top, and then $rnd.NextBytes instead of (New-Object Random).NextBytes when generating the file. – 
Jonathan Gilbert
 May 29, 2018 at 16:19
Add a comment
18

You can use PowerShell to generate cheap random data for your files:

[Byte[]] $out = @()
0..2047 | % {$out += Get-Random -Minimum 0 -Maximum 255}
[System.IO.File]::WriteAllBytes("myrandomfiletest", $out)
This uses an algorithm with a seed taken from the system clock, so don't use this for ANY serious cryptographic applications.

In addition, be wary of the performance degradation of Get-Random when increasing the size of the output file. More on this aspect here:

PowerShell random file generator too slow
Improve Powershell Performance to Generate a Random File
Share
Improve this answer
Follow
edited May 23, 2017 at 12:32
Community's user avatar
CommunityBot
111 silver badge
answered Sep 27, 2013 at 18:23
Gerrit's user avatar
Gerrit
85166 silver badges1111 bronze badges
Add a comment
16

I have been using Random Data File Creator and liking it, it creates binary files (i.e. not text files) filled with pseudo-random bits, it can quickly create very large files. To use it to create multiple small files you would need to script it, which would be very easy given it is command line.

Share
Improve this answer
Follow
edited Dec 25, 2015 at 11:57
mguassa's user avatar
mguassa
3,97122 gold badges1414 silver badges1919 bronze badges
answered Feb 5, 2010 at 19:20
David Waters's user avatar
David Waters
11.9k77 gold badges4141 silver badges7676 bronze badges
There are quite a few programs and cloud tools of this nature: raywoodcockslatest.wordpress.com/2021/08/21/dummy-files – 
Ray Woodcock
 May 17, 2022 at 14:08
Add a comment
8

Since you don't specify a language, I'll simply pick one at random. Here is a powershell script to do it:

$rootDir = 'C:\Temp\TestRandomFiles\'
$baseFile = $rootDir + "base.txt"
$desiredFileSize = 2*1KB
$fileCount = 50000
"start" | Out-File -Filepath $baseFile
While ($(Get-ChildItem -path $baseFile).Length -lt $desiredFileSize)
{
    $(Get-ChildItem -path $baseFile).Length | Out-File $baseFile -APPEND
}
for($i=1;$i -lt $fileCount;$i++)
{
    Copy-Item $baseFile "File$i.txt"
}
You'll have to change the variables to the parameters that you want of course.

Share
Improve this answer
Follow
answered Feb 10, 2009 at 19:47
EBGreen's user avatar
EBGreen
36.5k1212 gold badges6464 silver badges8484 bronze badges
1
oops...missed the random data requirement. Is that important? If so I can tweak it. – 
EBGreen
 Feb 10, 2009 at 19:48
1
If you are a PS whiz, I don't suppose you can do random data as I am keen to learn how this done! – 
Wil
 Jan 27, 2012 at 10:22 
I'm definitely not a whiz, but there are several ways. Basically you identify the data set that you want to randomize (say 0-9 and a-Z) then you randomly pick from that set to build the data for the file, then write it out to the file. If I have a chance later today, I'll alter the above code to use random data. – 
EBGreen
 Jan 27, 2012 at 15:12
@EBGreen thank You much! Best regards – 
Gennady G
 Nov 29, 2021 at 14:01
Add a comment
4

Instead of using Get-Random to generate the text as per user188737 & mguassa suggestions, I improved the speed by using GUIDs.

Function New-RandomFile {
    Param(
        $Path = '.', 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 
    (1..($FileSize/128)).foreach({-join ([guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-").SubString(1, 126) }) | set-content "$Path\$FileName"
}
This took 491 milliseconds to generate a 1mb file. Running:

New-RandomFile -FileSize 1mb
UPDATE:

I've updated my function to use a ScriptBlock, so you can replace the 'NewGuid()' method with anything you want.

In this scenario, I make 1kb chunks, since I know I'm never creating smaller files. This improved the speed of my function drastically!

Set-Content forces a NewLine at the end, which is why you need to remove 2 Characters each time you write to file. I've replaced it with [io.file]::WriteAllText() instead.

Function New-RandomFile_1kChunks {
    Param(
        $Path = (Resolve-Path '.').Path, 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 

    $Chunk = { [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-" }

    $Chunks = [math]::Ceiling($FileSize/1kb)

    [io.file]::WriteAllText("$Path\$FileName","$(-Join (1..($Chunks)).foreach({ $Chunk.Invoke() }))")

    Write-Warning "New-RandomFile: $Path\$FileName"

}
If you dont care that all chunks are random, you can simply Invoke() the generation of the 1kb chunk once.. this improves the speed drastically, but won't make the entire file random.

Function New-RandomFile_Fast {
    Param(
        $Path = (Resolve-Path '.').Path, 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 

    $Chunk = { [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-" }
    $Chunks = [math]::Ceiling($FileSize/1kb)
    $ChunkString = $Chunk.Invoke()

    [io.file]::WriteAllText("$Path\$FileName","$(-Join (1..($Chunks)).foreach({ $ChunkString }))")

    Write-Warning "New-RandomFile: $Path\$FileName"

}
Measure-Command all these changes to generate a 10mb file:

Executing New-RandomFile: 35.7688241 seconds.

Executing New-RandomFile_1kChunks: 25.1463777 seconds.

Executing New-RandomFile_Fast: 1.1626236 seconds.

Share
Improve this answer
Follow
edited Apr 3, 2017 at 23:04
answered Apr 1, 2017 at 2:39
Marc Kellerman's user avatar
Marc Kellerman
45622 silver badges1010 bronze badges
Add a comment
2

You'll have to create files in the normal way, and then populate them with randomized data, probably from a rand() function of some sort.

It really depends on your programming language. Windows itself certainly won't provide this capability.

There are a number of programming languages that could do this easily, however, including basic windows batch/CMD scripts. What language are you interested in using?

Share
Improve this answer
Follow
answered Feb 10, 2009 at 18:54
levand's user avatar
levand
8,39033 gold badges4040 silver badges5454 bronze badges
Add a comment
2

None of the answers here were cutting it for me, so here's a script which takes advantage of the Cryptography library to generate lots of random files.

This will generate files very quickly until your system's entropy is exhausted (on my PC this was about 4,000 files). After this it (and any other applications on your system that need cryptographic random numbers) will run very slowly. (In Linux terms, consider this script to use /dev/random instead of /dev/urandom)

$directory = (Get-Location).Path;
0..10000 | ForEach-Object {
    $size = 1023 * (Get-Random -Minimum 10 -Maximum 1536);
    $contents = [Byte[]]::new($size);

    $rng = [System.Security.Cryptography.RNGCryptoServiceProvider]::new();
    $rng.GetBytes($contents);

    $filename = "$directory\random$($_.ToString().PadLeft(5, '0')).txt"
    Write-Host $filename
    [System.IO.File]::WriteAllBytes($filename, $contents)
}
If you'd rather not deplete your system's entropy, replace the two $rng lines with these:

    $rng = [System.Random]::new();
    $rng.NextBytes($contents);
This will run much slower, but for large quantities of files (or larger files) it should be more reliable.

Share
Improve this answer
Follow
answered Apr 15, 2020 at 0:57
Joshua Walsh's user avatar
Joshua Walsh
1,88555 gold badges2525 silver badges5050 bronze badges
Add a comment
1

Yes, fsutil is great, but doesn't generate random data, just ASCII nulls.

I don't remember where I found this but searching on google these days I can still find it at: http://www.private-files.com/other/random.c.txt

I don't know how old this program is but at least as old as your question, probably somewhat older.

Anyway here's a program in C which creates files with a chi-squared test result of 0:

// ------------------------------------------------------------     
// Name: random.c  (program to create random files)
//     
// This "no-frills" program creates files with the following 
// characteristics: 
//
//    (1) Byte sequences are random (no predictability);
//    (2) Files produced are binary files; 
//    (3) File sizes are multiples of 256; 
//    (4) Files will have a chi-squared test result of 0
//        (see analyze.exe by Wenger for explanation)
//  
//              Programmer:  Scott Wenger
//                           Box 802
//                           Stevens Point, WI 54481
//                           panther@wctc.net
//
//       Note:  part of this code is from Knuth Volume II
// 
//  Enhancements and modifications of this program are left 
//  to the imagination and creativity of the programmer.
//  Check your compiler for required header files.  You may 
//  need to include the iostream header.
//
//  Random files are of potential use to cryptographers
//  for the purpose of encryption.  
//  
//  To analyze files produced by this program, see 
//  the analyze.exe program by Scott Wenger (found at
//  http://www.coredcs.com/sware.html)
// ------------------------------------------------------------


// This program works in the following way:
// The time is used to seed the random number generator.
// Using Knuth's algorithm, random numbers are generated
// in the range of 0 to 255 (corresponding to 256 ASCII chars.)
// When random numbers are generated they are marked as used and 
// are not re-used until all 256 ASCII values appear.  Characters 
// are written to disk and the process continues until the
// desired file size is reached.  Output is a random binary file
// called random.bin (placed in the root directory)
// The controlled filesize along with the placeholder feature 
// of this code forces a very high degree of randomness in 
// the output file. 

#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void init_mm();
void clear_array(); 
int  number_range(int minval, int maxval);
int  number_mm();

static int rgiState[2 + 55]; 
int place_holder[256];          // to keep track of numbers already generated

int main()
{
  mainprogram();
  return 0;
}

int mainprogram()
{
  int ch; 
  int c_used = 0;  // counter of chars in placeholder
  int done = 0; 
  int random;

  char buffer[2];

  long x;
  long byte_size = 0L;
  FILE *fp;

  clear_array();
  init_mm();  // seed random number generator

  // create a random file of length specified by user
  printf("\nrandom.exe originally by Scott Wenger");
  printf("\nThis program creates a random binary file.\n");
  printf("\nPlease specify length of random file to create (in megabytes): ");  

  scanf("%ld", &byte_size);

  while (byte_size > 1000 || byte_size <= 0 )
  {
    printf("\nWill not create files larger than a gigabyte! ");
    printf("\nPlease specify length of random file to create (in megabytes): ");
    flushall();
    scanf("%ld", &byte_size);
  }

  byte_size = byte_size * 1024 * 1024;

  if ( (fp = fopen("random.bin", "wb"))  == NULL) {
    fprintf(stderr, "\nOutput file (random.bin) could not be created.");      
    fflush(stdout);
    exit(1);
  }

  for (x = 0L; x < byte_size; x++) {

    if (c_used == 256) {
      clear_array();
      c_used = 0;
    }

    random = number_range(0, 255);    // use all ASCII values

    if ( *(place_holder + random) ) {  // already used, find another
      done = 0;
      while (!done) {
        random = number_range(0, 255);
        if ( *(place_holder + random) == 0) {
          *(place_holder + random) = 1;
          done = 1;
        }
      }         
    }
    else *(place_holder + random) = 1;  // use it and mark as used 

    c_used++;   // found next character so increment counter

    sprintf(buffer, "%c", random);  // convert ASCII value to char 
    ch = buffer[0];
    fputc(ch, fp); // write to file
  }

  fclose(fp);

  printf("\nDone. File \"random.bin\" was created (size: %ld bytes)", byte_size);
  printf("\nOutput file is in the root directory (c:\\random.bin)\n");
  return(0);
}

// ---------------------------------------------------------------------------------

void clear_array()
{
  register int x;
  for (x = 0; x < 256; x++) 
    *(place_holder + x) = 0;
}

// ---------------------------------------------------------------------------------

int number_mm()
{
    int *piState;
    int iState1;
    int iState2;
    int iRand;

    piState     = &rgiState[2];
    iState1     = piState[-2];
    iState2     = piState[-1];
    iRand       = ( piState[iState1] + piState[iState2] )
                & ( ( 1 << 30 ) - 1 );
    piState[iState1]    = iRand;

    if ( ++iState1 == 55 )  iState1 = 0;
    if ( ++iState2 == 55 )  iState2 = 0;

    piState[-2]     = iState1;
    piState[-1]     = iState2;

    return(iRand >> 6);
}

// ---------------------------------------------------------------------------------

//  Generate a random number.

int number_range( int minval, int maxval )
{
  int power, number;

  if ( ( maxval = maxval - minval + 1 ) <= 1 ) return (minval);

  for ( power = 2; power < maxval; power <<= 1 )
    ;
  while ( ( number = number_mm( ) & ( power - 1 ) ) >= maxval )
    ;
  return(minval + number);
}

// ---------------------------------------------------------------------------------

// Mitchell-Moore algorithm from Knuth Volume II. 

void init_mm( )
{
  int *piState;
  int iState;

  piState = &rgiState[2];
  piState[-2]   = 55 - 55;
  piState[-1]   = 55 - 24;
  piState[0]    = ( (int) time( NULL ) ) & ( ( 1 << 30 ) - 1 );
  piState[1]    = 1;

  for ( iState = 2; iState < 55; iState++ ) 
  {
    piState[iState] = ( piState[iState-1] + piState[iState-2] )
                      &  ( ( 1 << 30 ) - 1 );
  }
}

// -------------------- End -------------------------------------------------------
Share
Improve this answer
Follow
answered Aug 10, 2016 at 13:38
Rubenisme's user avatar
Rubenisme
78711 gold badge88 silver badges1515 bronze badges
Add a comment
1

So, i decided to add an accurate answer this time.

language is powershell. assumptions: filenames will be sequential and not random. file contents are to be cryptographically secure and unique. file location to be C:\temp\

#create a fixed size byte array for later use.  make it the required file size.
$bytearray = New-Object byte[] 2048

#create and start a stopwatch object to measure how long it all takes.
$stopwatch = [Diagnostics.Stopwatch]::StartNew()

#create a CSRNG object
$RNGObject = New-Object Security.Cryptography.RNGCryptoServiceProvider

# set up a loop to run 50000 times
0..49999 | Foreach-Object {

    # create a file stream handle with a name format 'filennnnn'
    $stream = New-Object System.IO.FileStream("c:\temp\file$("{0:D5}" -f $_)"), Create

    # and a stream writer handle
    $writer = New-Object System.IO.BinaryWriter($stream)

    # Fill our array from the CSRNG
    $RNGObject.GetNonZeroBytes($bytearray)

    # Append to the current file
    $writer.write($bytearray)

    # Close the stream
    $stream.close()

}
About
Products
For Teams
Search…
Join Stack Overflow to find the best answer to your technical question, help others answer theirs.

Home
PUBLIC
Questions
Tags
Users
Companies
COLLECTIVES
Explore Collectives
TEAMS
Stack Overflow for Teams – Start collaborating and sharing organizational knowledge. 
Generating Random Files in Windows
Asked 14 years, 3 months ago
Modified 5 months ago
Viewed 85k times
42

Does anyone have a way to generate files of random data in Windows? I would like to generate 50,000 small (2K) files as an example.

windows
Share
Improve this question
Follow
asked Feb 10, 2009 at 18:51
Jeff
2
Could you share with us whether you want text files or binary files? Could you also comment as to what programming languages you have access to (if any)? Do you have MS Office installed? Also, not very relevant, but what version of windows are you using? – 
user62572
 Feb 10, 2009 at 20:05
Add a comment
16 Answers
Sorted by:

Highest score (default)
34

You can run fsutil in a batch loop to create files of any size.

fsutil file createnew filename.extension 2000
Share
Improve this answer
Follow
answered Feb 10, 2009 at 19:01
Bogdan's user avatar
Bogdan
3,03511 gold badge2222 silver badges2020 bronze badges
I just found that utility. Didn't know it existed before. thebackroomtech.com/2009/01/16/… – 
beach
 Feb 10, 2009 at 19:04
41
However, it doesn't create random data. Just blank files. – 
beach
 Feb 10, 2009 at 19:07
And it seems to require admin permissions. Going with the powershell. – 
Mathias Mamsch
 Oct 25, 2017 at 7:21
Add a comment
21

One-liner in Powershell:

$out = new-object byte[] 1048576; (new-object Random).NextBytes($out); [IO.File]::WriteAllBytes('d:\file.bin', $out)
This is lightning fast, compared to @user188737 solution.

Share
Improve this answer
Follow
answered Sep 26, 2017 at 7:07
gwiazdorrr's user avatar
gwiazdorrr
6,16122 gold badges2727 silver badges3636 bronze badges
1
Every single file that this one liner creates is identical. Is there any way to make the content of each file different – 
Dhiwakar Ravikumar
 Apr 15, 2018 at 4:47
3
Are you sure this is the case? I tried it on my system, ran it 3 times, got 3 distinct files. The constructor for the Random type is by default based on the system time, so perhaps if you run this multiple times in very quick succession, you might get identical files. You could avoid this by creating a single Random object and then reusing it for each consecutive file: $rnd = New-Object Random; once at the top, and then $rnd.NextBytes instead of (New-Object Random).NextBytes when generating the file. – 
Jonathan Gilbert
 May 29, 2018 at 16:19
Add a comment
18

You can use PowerShell to generate cheap random data for your files:

[Byte[]] $out = @()
0..2047 | % {$out += Get-Random -Minimum 0 -Maximum 255}
[System.IO.File]::WriteAllBytes("myrandomfiletest", $out)
This uses an algorithm with a seed taken from the system clock, so don't use this for ANY serious cryptographic applications.

In addition, be wary of the performance degradation of Get-Random when increasing the size of the output file. More on this aspect here:

PowerShell random file generator too slow
Improve Powershell Performance to Generate a Random File
Share
Improve this answer
Follow
edited May 23, 2017 at 12:32
Community's user avatar
CommunityBot
111 silver badge
answered Sep 27, 2013 at 18:23
Gerrit's user avatar
Gerrit
85166 silver badges1111 bronze badges
Add a comment
16

I have been using Random Data File Creator and liking it, it creates binary files (i.e. not text files) filled with pseudo-random bits, it can quickly create very large files. To use it to create multiple small files you would need to script it, which would be very easy given it is command line.

Share
Improve this answer
Follow
edited Dec 25, 2015 at 11:57
mguassa's user avatar
mguassa
3,97122 gold badges1414 silver badges1919 bronze badges
answered Feb 5, 2010 at 19:20
David Waters's user avatar
David Waters
11.9k77 gold badges4141 silver badges7676 bronze badges
There are quite a few programs and cloud tools of this nature: raywoodcockslatest.wordpress.com/2021/08/21/dummy-files – 
Ray Woodcock
 May 17, 2022 at 14:08
Add a comment
8

Since you don't specify a language, I'll simply pick one at random. Here is a powershell script to do it:

$rootDir = 'C:\Temp\TestRandomFiles\'
$baseFile = $rootDir + "base.txt"
$desiredFileSize = 2*1KB
$fileCount = 50000
"start" | Out-File -Filepath $baseFile
While ($(Get-ChildItem -path $baseFile).Length -lt $desiredFileSize)
{
    $(Get-ChildItem -path $baseFile).Length | Out-File $baseFile -APPEND
}
for($i=1;$i -lt $fileCount;$i++)
{
    Copy-Item $baseFile "File$i.txt"
}
You'll have to change the variables to the parameters that you want of course.

Share
Improve this answer
Follow
answered Feb 10, 2009 at 19:47
EBGreen's user avatar
EBGreen
36.5k1212 gold badges6464 silver badges8484 bronze badges
1
oops...missed the random data requirement. Is that important? If so I can tweak it. – 
EBGreen
 Feb 10, 2009 at 19:48
1
If you are a PS whiz, I don't suppose you can do random data as I am keen to learn how this done! – 
Wil
 Jan 27, 2012 at 10:22 
I'm definitely not a whiz, but there are several ways. Basically you identify the data set that you want to randomize (say 0-9 and a-Z) then you randomly pick from that set to build the data for the file, then write it out to the file. If I have a chance later today, I'll alter the above code to use random data. – 
EBGreen
 Jan 27, 2012 at 15:12
@EBGreen thank You much! Best regards – 
Gennady G
 Nov 29, 2021 at 14:01
Add a comment
4

Instead of using Get-Random to generate the text as per user188737 & mguassa suggestions, I improved the speed by using GUIDs.

Function New-RandomFile {
    Param(
        $Path = '.', 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 
    (1..($FileSize/128)).foreach({-join ([guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-").SubString(1, 126) }) | set-content "$Path\$FileName"
}
This took 491 milliseconds to generate a 1mb file. Running:

New-RandomFile -FileSize 1mb
UPDATE:

I've updated my function to use a ScriptBlock, so you can replace the 'NewGuid()' method with anything you want.

In this scenario, I make 1kb chunks, since I know I'm never creating smaller files. This improved the speed of my function drastically!

Set-Content forces a NewLine at the end, which is why you need to remove 2 Characters each time you write to file. I've replaced it with [io.file]::WriteAllText() instead.

Function New-RandomFile_1kChunks {
    Param(
        $Path = (Resolve-Path '.').Path, 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 

    $Chunk = { [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-" }

    $Chunks = [math]::Ceiling($FileSize/1kb)

    [io.file]::WriteAllText("$Path\$FileName","$(-Join (1..($Chunks)).foreach({ $Chunk.Invoke() }))")

    Write-Warning "New-RandomFile: $Path\$FileName"

}
If you dont care that all chunks are random, you can simply Invoke() the generation of the 1kb chunk once.. this improves the speed drastically, but won't make the entire file random.

Function New-RandomFile_Fast {
    Param(
        $Path = (Resolve-Path '.').Path, 
        $FileSize = 1kb, 
        $FileName = [guid]::NewGuid().Guid + '.txt'
        ) 

    $Chunk = { [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid +
               [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid + [guid]::NewGuid().Guid -Replace "-" }
    $Chunks = [math]::Ceiling($FileSize/1kb)
    $ChunkString = $Chunk.Invoke()

    [io.file]::WriteAllText("$Path\$FileName","$(-Join (1..($Chunks)).foreach({ $ChunkString }))")

    Write-Warning "New-RandomFile: $Path\$FileName"

}
Measure-Command all these changes to generate a 10mb file:

Executing New-RandomFile: 35.7688241 seconds.

Executing New-RandomFile_1kChunks: 25.1463777 seconds.

Executing New-RandomFile_Fast: 1.1626236 seconds.

Share
Improve this answer
Follow
edited Apr 3, 2017 at 23:04
answered Apr 1, 2017 at 2:39
Marc Kellerman's user avatar
Marc Kellerman
45622 silver badges1010 bronze badges
Add a comment
2

You'll have to create files in the normal way, and then populate them with randomized data, probably from a rand() function of some sort.

It really depends on your programming language. Windows itself certainly won't provide this capability.

There are a number of programming languages that could do this easily, however, including basic windows batch/CMD scripts. What language are you interested in using?

Share
Improve this answer
Follow
answered Feb 10, 2009 at 18:54
levand's user avatar
levand
8,39033 gold badges4040 silver badges5454 bronze badges
Add a comment
2

None of the answers here were cutting it for me, so here's a script which takes advantage of the Cryptography library to generate lots of random files.

This will generate files very quickly until your system's entropy is exhausted (on my PC this was about 4,000 files). After this it (and any other applications on your system that need cryptographic random numbers) will run very slowly. (In Linux terms, consider this script to use /dev/random instead of /dev/urandom)

$directory = (Get-Location).Path;
0..10000 | ForEach-Object {
    $size = 1023 * (Get-Random -Minimum 10 -Maximum 1536);
    $contents = [Byte[]]::new($size);

    $rng = [System.Security.Cryptography.RNGCryptoServiceProvider]::new();
    $rng.GetBytes($contents);

    $filename = "$directory\random$($_.ToString().PadLeft(5, '0')).txt"
    Write-Host $filename
    [System.IO.File]::WriteAllBytes($filename, $contents)
}
If you'd rather not deplete your system's entropy, replace the two $rng lines with these:

    $rng = [System.Random]::new();
    $rng.NextBytes($contents);
This will run much slower, but for large quantities of files (or larger files) it should be more reliable.

Share
Improve this answer
Follow
answered Apr 15, 2020 at 0:57
Joshua Walsh's user avatar
Joshua Walsh
1,88555 gold badges2525 silver badges5050 bronze badges
Add a comment
1

Yes, fsutil is great, but doesn't generate random data, just ASCII nulls.

I don't remember where I found this but searching on google these days I can still find it at: http://www.private-files.com/other/random.c.txt

I don't know how old this program is but at least as old as your question, probably somewhat older.

Anyway here's a program in C which creates files with a chi-squared test result of 0:

// ------------------------------------------------------------     
// Name: random.c  (program to create random files)
//     
// This "no-frills" program creates files with the following 
// characteristics: 
//
//    (1) Byte sequences are random (no predictability);
//    (2) Files produced are binary files; 
//    (3) File sizes are multiples of 256; 
//    (4) Files will have a chi-squared test result of 0
//        (see analyze.exe by Wenger for explanation)
//  
//              Programmer:  Scott Wenger
//                           Box 802
//                           Stevens Point, WI 54481
//                           panther@wctc.net
//
//       Note:  part of this code is from Knuth Volume II
// 
//  Enhancements and modifications of this program are left 
//  to the imagination and creativity of the programmer.
//  Check your compiler for required header files.  You may 
//  need to include the iostream header.
//
//  Random files are of potential use to cryptographers
//  for the purpose of encryption.  
//  
//  To analyze files produced by this program, see 
//  the analyze.exe program by Scott Wenger (found at
//  http://www.coredcs.com/sware.html)
// ------------------------------------------------------------


// This program works in the following way:
// The time is used to seed the random number generator.
// Using Knuth's algorithm, random numbers are generated
// in the range of 0 to 255 (corresponding to 256 ASCII chars.)
// When random numbers are generated they are marked as used and 
// are not re-used until all 256 ASCII values appear.  Characters 
// are written to disk and the process continues until the
// desired file size is reached.  Output is a random binary file
// called random.bin (placed in the root directory)
// The controlled filesize along with the placeholder feature 
// of this code forces a very high degree of randomness in 
// the output file. 

#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void init_mm();
void clear_array(); 
int  number_range(int minval, int maxval);
int  number_mm();

static int rgiState[2 + 55]; 
int place_holder[256];          // to keep track of numbers already generated

int main()
{
  mainprogram();
  return 0;
}

int mainprogram()
{
  int ch; 
  int c_used = 0;  // counter of chars in placeholder
  int done = 0; 
  int random;

  char buffer[2];

  long x;
  long byte_size = 0L;
  FILE *fp;

  clear_array();
  init_mm();  // seed random number generator

  // create a random file of length specified by user
  printf("\nrandom.exe originally by Scott Wenger");
  printf("\nThis program creates a random binary file.\n");
  printf("\nPlease specify length of random file to create (in megabytes): ");  

  scanf("%ld", &byte_size);

  while (byte_size > 1000 || byte_size <= 0 )
  {
    printf("\nWill not create files larger than a gigabyte! ");
    printf("\nPlease specify length of random file to create (in megabytes): ");
    flushall();
    scanf("%ld", &byte_size);
  }

  byte_size = byte_size * 1024 * 1024;

  if ( (fp = fopen("random.bin", "wb"))  == NULL) {
    fprintf(stderr, "\nOutput file (random.bin) could not be created.");      
    fflush(stdout);
    exit(1);
  }

  for (x = 0L; x < byte_size; x++) {

    if (c_used == 256) {
      clear_array();
      c_used = 0;
    }

    random = number_range(0, 255);    // use all ASCII values

    if ( *(place_holder + random) ) {  // already used, find another
      done = 0;
      while (!done) {
        random = number_range(0, 255);
        if ( *(place_holder + random) == 0) {
          *(place_holder + random) = 1;
          done = 1;
        }
      }         
    }
    else *(place_holder + random) = 1;  // use it and mark as used 

    c_used++;   // found next character so increment counter

    sprintf(buffer, "%c", random);  // convert ASCII value to char 
    ch = buffer[0];
    fputc(ch, fp); // write to file
  }

  fclose(fp);

  printf("\nDone. File \"random.bin\" was created (size: %ld bytes)", byte_size);
  printf("\nOutput file is in the root directory (c:\\random.bin)\n");
  return(0);
}

// ---------------------------------------------------------------------------------

void clear_array()
{
  register int x;
  for (x = 0; x < 256; x++) 
    *(place_holder + x) = 0;
}

// ---------------------------------------------------------------------------------

int number_mm()
{
    int *piState;
    int iState1;
    int iState2;
    int iRand;

    piState     = &rgiState[2];
    iState1     = piState[-2];
    iState2     = piState[-1];
    iRand       = ( piState[iState1] + piState[iState2] )
                & ( ( 1 << 30 ) - 1 );
    piState[iState1]    = iRand;

    if ( ++iState1 == 55 )  iState1 = 0;
    if ( ++iState2 == 55 )  iState2 = 0;

    piState[-2]     = iState1;
    piState[-1]     = iState2;

    return(iRand >> 6);
}

// ---------------------------------------------------------------------------------

//  Generate a random number.

int number_range( int minval, int maxval )
{
  int power, number;

  if ( ( maxval = maxval - minval + 1 ) <= 1 ) return (minval);

  for ( power = 2; power < maxval; power <<= 1 )
    ;
  while ( ( number = number_mm( ) & ( power - 1 ) ) >= maxval )
    ;
  return(minval + number);
}

// ---------------------------------------------------------------------------------

// Mitchell-Moore algorithm from Knuth Volume II. 

void init_mm( )
{
  int *piState;
  int iState;

  piState = &rgiState[2];
  piState[-2]   = 55 - 55;
  piState[-1]   = 55 - 24;
  piState[0]    = ( (int) time( NULL ) ) & ( ( 1 << 30 ) - 1 );
  piState[1]    = 1;

  for ( iState = 2; iState < 55; iState++ ) 
  {
    piState[iState] = ( piState[iState-1] + piState[iState-2] )
                      &  ( ( 1 << 30 ) - 1 );
  }
}

// -------------------- End -------------------------------------------------------
Share
Improve this answer
Follow
answered Aug 10, 2016 at 13:38
Rubenisme's user avatar
Rubenisme
78711 gold badge88 silver badges1515 bronze badges
Add a comment
1

So, i decided to add an accurate answer this time.

language is powershell. assumptions: filenames will be sequential and not random. file contents are to be cryptographically secure and unique. file location to be C:\temp\

#create a fixed size byte array for later use.  make it the required file size.
$bytearray = New-Object byte[] 2048

#create and start a stopwatch object to measure how long it all takes.
$stopwatch = [Diagnostics.Stopwatch]::StartNew()

#create a CSRNG object
$RNGObject = New-Object Security.Cryptography.RNGCryptoServiceProvider

# set up a loop to run 50000 times
0..49999 | Foreach-Object {

    # create a file stream handle with a name format 'filennnnn'
    $stream = New-Object System.IO.FileStream("c:\temp\file$("{0:D5}" -f $_)"), Create

    # and a stream writer handle
    $writer = New-Object System.IO.BinaryWriter($stream)

    # Fill our array from the CSRNG
    $RNGObject.GetNonZeroBytes($bytearray)

    # Append to the current file
    $writer.write($bytearray)

    # Close the stream
    $stream.close()

}